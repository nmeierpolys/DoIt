PhpCron, a scheduling utility that provides a convenient browser interface,
Phpcron Admin

[1]
[    PhpCron, a scheduling utility that provides a convenient browser interface, Phpcron Admin
    ]

David Druffner

           ddruff@gemini1consulting.com
         www.gemini1consulting.com/dcd/

Copyright © 2001 by David C. Druffner

Revision History
 Revision v. 0.5.1.0 10-09-2001 Revised by: dcd
 Initial Manual for v.0.5 of phpcron

Manual for Phpcron,a [2]PHP command line utility which allows you to
schedule programs to run at certain specified times similar to the Unix
standard Crond daemon (which it can be used in place of when started as a
daemon or in conjunction with when Phpcron is being used as a "Virtual
Daemon"). This manual also covers Phpcron Admin,an optional browser based
interface to Phpcron, allowing a user to remotely schedule programs and
change Phpcron options in a user friendly way without having to deal with
console based sessions using ssh, telnet, or arcane text editors. Download
updates to this manual and to Phpcron at [3]Gemini 1 Consulting, LLC.
Phpcron and Phpcron Admin provide an ideal solution for web hosts who wish
to provide a graphical interface with the scheduling power of Crond.

An [4] online manual is available which displays users comments,
modifications, and tips, as well as any author comments since this manual
was published.

The Phpcron scripts have been heavily commented with inline documentation
using a [5]version of Robodoc which this author revised to produce
[6]DocBook SGML. Attached as an Appendix is the generated source code
documentation.

  ------------------------------------------------------------------------

Table of Contents
1. Introduction

1.1. What is Phpcron?
1.2. Why Use Phpcron instead of just Unix's Crond?
1.3. Copyright Information
1.4. Disclaimer
1.5. Phpcron License
1.6. Manual Version
1.7. Credits
1.8. Feedback
1.9. Translations

2. Download Phpcron
3. System Requirements
4. Installation
5. Scheduling Program Execution
6. Command Line Execution
7. Phpcron Options
8. Phpcron Admin

8.1. Overview
8.2. Control Panel
8.3. Edit Scheduled Programs

9. Modes and the Virtual Daemon

9.1. Modes (Daemon and Non-Daemon)
9.2. Virtual Daemon

10. Code History
11. Demo
12. Code Contributions
13. Code Reference
A. Phpcron Code Reference

A.1. Phpcron Source Code Reference

A.1.1. Source Files

A.1.1.1. phpcron.php
A.1.1.2. phpcron_admin.php
A.1.1.3. phpcron_commonlib.php

A.1.2. Functions

A.1.2.1. appendToFile
A.1.2.2. buildNewtab
A.1.2.3. checkPhpVersion
A.1.2.4. clearLogFile
A.1.2.5. cpPhpcron
A.1.2.6. deleteFile
A.1.2.7. downloadFile
A.1.2.8. editTabByForm
A.1.2.9. formatPath
A.1.2.10. fullEditBox
A.1.2.11. getAssignmentInfo
A.1.2.12. getComments
A.1.2.13. getFormElement
A.1.2.14. getProcessInfo()
A.1.2.15. isBadPhp
A.1.2.16. isCronTimeParamsBad
A.1.2.17. isInteger
A.1.2.18. isIntegerInRange
A.1.2.19. isOtherPhpcrond
A.1.2.20. isPathbad
A.1.2.21. isTabFormBad
A.1.2.22. is_email
A.1.2.23. killOtherPhpcron
A.1.2.24. mailAttachment
A.1.2.25. menuBar
A.1.2.26. pageTitle
A.1.2.27. parseCronTimeParams
A.1.2.28. parseUserConfig
A.1.2.29. rebuildUserCfg
A.1.2.30. saveFile
A.1.2.31. sendOutput
A.1.2.32. stopOtherPhpcron
A.1.2.33. stopThisProcess
A.1.2.34. stripPhp
A.1.2.35. tabTopComments

A.1.3. Variables

A.1.3.1. $admin_email_address
A.1.3.2. $admin_subpage
A.1.3.3. $assignment_info
A.1.3.4. $cl_help
A.1.3.5. $daemon_mode
A.1.3.6. $debug
A.1.3.7. $error_email_address
A.1.3.8. $left_mlc_ch
A.1.3.9. $license
A.1.3.10. $log_result
A.1.3.11. $log_result_file
A.1.3.12. $mail_errors
A.1.3.13. $mail_success
A.1.3.14. $phpcron_directory
A.1.3.15. $phpcron_file
A.1.3.16. $phpcron_off
A.1.3.17. $phpcron_output
A.1.3.18. $phpcron_psinfo_file
A.1.3.19. $phpcron_venabled_file
A.1.3.20. $phpcrontab_filename
A.1.3.21. $pid
A.1.3.22. $redirect_output
A.1.3.23. $right_mlc_ch
A.1.3.24. $sc_ch
A.1.3.25. $secure
A.1.3.26. $slow_debug_scroll
A.1.3.27. $start_time
A.1.3.28. $suppress_output
A.1.3.29. $system_name
A.1.3.30. $uc_contents
A.1.3.31. $uc_contents_array
A.1.3.32. $uc_contents_length
A.1.3.33. $user_config_file
A.1.3.34. $viewed_by_browser
A.1.3.35. phpcron_directory

A.1.4. Constants

A.1.4.1. CURRENT_DIRECTORY
A.1.4.2. CURRENT_DIRECTORY

A.1.5. Generic

A.1.5.1. phpcron_admin_readme
A.1.5.2. phpcron_commonlib_readme
A.1.5.3. phpcron_readme

A.2. PHPCRON/phpcron_readme

A.2.1. NAME
A.2.2. DESCRIPTION
A.2.3. AUTHOR
A.2.4. COPYRIGHT
A.2.5. CREATION DATE
A.2.6. MODIFICATION HISTORY
A.2.7. BUGS
A.2.8. NOTES

A.3. phpcron/CURRENT_DIRECTORY

A.3.1. NAME
A.3.2. DESCRIPTION

A.4. phpcron/phpcron_directory

A.4.1. NAME
A.4.2. DESCRIPTION

A.5. phpcron/$start_time

A.5.1. NAME
A.5.2. DESCRIPTION

A.6. phpcron/$phpcrontab_filename

A.6.1. NAME
A.6.2. DESCRIPTION

A.7. phpcron/$debug

A.7.1. NAME
A.7.2. DESCRIPTION

A.8. phpcron/$slow_debug_scroll

A.8.1. NAME
A.8.2. DESCRIPTION

A.9. phpcron/$log_result

A.9.1. NAME
A.9.2. DESCRIPTION

A.10. phpcron/$log_result_file

A.10.1. NAME
A.10.2. DESCRIPTION
A.10.3. NOTES

A.11. phpcron/$mail_success

A.11.1. NAME
A.11.2. DESCRIPTION

A.12. phpcron/$admin_email_address

A.12.1. NAME
A.12.2. DESCRIPTION

A.13. phpcron/$mail_errors

A.13.1. NAME
A.13.2. DESCRIPTION
A.13.3. NOTES

A.14. phpcron/$error_email_address

A.14.1. NAME
A.14.2. DESCRIPTION

A.15. phpcron/$system_name

A.15.1. NAME
A.15.2. DESCRIPTION

A.16. phpcron/$suppress_output

A.16.1. NAME
A.16.2. DESCRIPTION

A.17. phpcron/$daemon_mode

A.17.1. NAME
A.17.2. DESCRIPTION

A.18. phpcron/stopThisProcess

A.18.1. NAME
A.18.2. SYNOPSIS
A.18.3. FUNCTION
A.18.4. INPUTS
A.18.5. SOURCE

A.19. phpcron/killOtherPhpcron

A.19.1. NAME
A.19.2. SYNOPSIS
A.19.3. FUNCTION
A.19.4. NOTES
A.19.5. RESULT
A.19.6. BUGS
A.19.7. SOURCE

A.20. phpcron/$pid
A.21. phpcron/$cl_help

A.21.1. NAME
A.21.2. DESCRIPTION
A.21.3. SOURCE

A.22. phpcron/$redirect_output

A.22.1. NAME
A.22.2. DESCRIPTION

A.23. PHPCRON/phpcron_admin_readme

A.23.1. NAME
A.23.2. AUTHOR
A.23.3. DESCRIPTION
A.23.4. COPYRIGHT
A.23.5. BUGS
A.23.6. NOTES

A.24. phpcron_admin/CURRENT_DIRECTORY

A.24.1. NAME
A.24.2. DESCRIPTION

A.25. phpcron_admin/$phpcron_directory

A.25.1. NAME
A.25.2. DESCRIPTION

A.26. phpcron_admin/$phpcron_output

A.26.1. NAME
A.26.2. DESCRIPTION

A.27. phpcron_admin/$secure

A.27.1. NAME
A.27.2. DESCRIPTION

A.28. phpcron_admin/$user_config_file

A.28.1. NAME

A.29. phpcron_admin/$left_mlc_ch

A.29.1. NAME

A.30. phpcron_admin/$right_mlc_ch

A.30.1. NAME

A.31. phpcron_admin/$sc_ch

A.31.1. NAME

A.32. phpcron_admin/$uc_contents

A.32.1. NAME
A.32.2. NOTES

A.33. phpcron_admin/$uc_contents_length

A.33.1. NAME

A.34. phpcron_admin/$admin_subpage

A.34.1. NAME

A.35. phpcron_admin/clearLogFile

A.35.1. NAME
A.35.2. SYNOPSIS
A.35.3. INPUTS
A.35.4. FUNCTION
A.35.5. RESULT
A.35.6. SOURCE

A.36. phpcron_admin/isBadPhp

A.36.1. NAME
A.36.2. SYNOPSIS
A.36.3. FUNCTION
A.36.4. INPUTS
A.36.5. PURPOSE
A.36.6. RESULT
A.36.7. NOTES
A.36.8. SOURCE

A.37. phpcron_admin/isTabFormBad

A.37.1. NAME
A.37.2. SYNOPSIS
A.37.3. FUNCTION
A.37.4. INPUTS
A.37.5. RESULT
A.37.6. NOTES
A.37.7. SOURCE

A.38. phpcron_admin/menuBar

A.38.1. NAME
A.38.2. SYNOPSIS
A.38.3. FUNCTION
A.38.4. INPUTS
A.38.5. RESULT
A.38.6. SOURCE

A.39. phpcron_admin/pageTitle

A.39.1. NAME
A.39.2. SYNOPSIS
A.39.3. FUNCTION
A.39.4. INPUTS
A.39.5. RESULT
A.39.6. SOURCE

A.40. phpcron_admin/buildNewtab

A.40.1. NAME
A.40.2. SYNOPSIS
A.40.3. FUNCTION
A.40.4. INPUTS
A.40.5. RESULT
A.40.6. NOTES
A.40.7. SOURCE

A.41. phpcron_admin/cpPhpcron

A.41.1. NAME
A.41.2. SYNOPSIS
A.41.3. FUNCTION
A.41.4. INPUTS
A.41.5. RESULT
A.41.6. SOURCE

A.42. phpcron_admin/editTabByForm

A.42.1. NAME
A.42.2. SYNOPSIS
A.42.3. FUNCTION
A.42.4. INPUTS
A.42.5. RESULT
A.42.6. SOURCE

A.43. phpcron_admin/fullEditBox

A.43.1. NAME
A.43.2. SYNOPSIS
A.43.3. FUNCTION
A.43.4. INPUTS
A.43.5. RESULT
A.43.6. SOURCE

A.44. phpcron_admin/getAssignmentInfo

A.44.1. NAME
A.44.2. SYNOPSIS
A.44.3. FUNCTION
A.44.4. INPUTS
A.44.5. RESULT
A.44.6. SOURCE

A.45. phpcron_admin/getComments

A.45.1. NAME
A.45.2. SYNOPSIS
A.45.3. FUNCTION
A.45.4. INPUTS
A.45.5. RESULT
A.45.6. SOURCE

A.46. phpcron_admin/getFormElement

A.46.1. NAME
A.46.2. SYNOPSIS
A.46.3. FUNCTION
A.46.4. INPUTS
A.46.5. RESULT
A.46.6. NOTES
A.46.7. SOURCE

A.47. phpcron_admin/$uc_contents_array

A.47.1. NAME
A.47.2. DESCRIPTION
A.47.3. NOTES

A.48. phpcron_admin/$assignment_info

A.48.1. NAME
A.48.2. DESCRIPTION
A.48.3. NOTES

A.49. phpcron_admin/parseUserConfig

A.49.1. NAME
A.49.2. SYNOPSIS
A.49.3. FUNCTION
A.49.4. INPUTS
A.49.5. RESULT
A.49.6. NOTES
A.49.7. SOURCE

A.50. phpcron_admin/rebuildUserCfg

A.50.1. NAME
A.50.2. SYNOPSIS
A.50.3. FUNCTION
A.50.4. INPUTS
A.50.5. RESULT
A.50.6. NOTES
A.50.7. SOURCE

A.51. phpcron_admin/stripPhp

A.51.1. NAME
A.51.2. SYNOPSIS
A.51.3. FUNCTION
A.51.4. INPUTS
A.51.5. RESULT
A.51.6. SOURCE

A.52. phpcron_admin/tabTopComments

A.52.1. NAME
A.52.2. SYNOPSIS
A.52.3. FUNCTION
A.52.4. INPUTS
A.52.5. RESULT
A.52.6. NOTES
A.52.7. SOURCE

A.53. PHPCRON/phpcron_commonlib_readme

A.53.1. NAME
A.53.2. DESCRIPTION
A.53.3. AUTHOR
A.53.4. COPYRIGHT
A.53.5. BUGS
A.53.6. NOTES

A.54. phpcron_commonlib/$license

A.54.1. NAME
A.54.2. DESCRIPTION

A.55. phpcron_commonlib/$phpcron_file

A.55.1. NAME
A.55.2. DESCRIPTION

A.56. phpcron_commonlib/$phpcron_psinfo_file

A.56.1. NAME
A.56.2. DESCRIPTION

A.57. phpcron_commonlib/$phpcron_venabled_file

A.57.1. NAME
A.57.2. DESCRIPTION

A.58. phpcron_commonlib/$phpcron_off

A.58.1. NAME
A.58.2. NAME
A.58.3. FUNCTION

A.59. phpcron_commonlib/$viewed_by_browser

A.59.1. NAME
A.59.2. FUNCTION
A.59.3. BUGS
A.59.4. NOTES
A.59.5. SOURCE

A.60. phpcron_commonlib/checkPhpVersion

A.60.1. NAME
A.60.2. SYNOPSIS
A.60.3. FUNCTION
A.60.4. INPUTS
A.60.5. RESULT
A.60.6. SOURCE

A.61. phpcron_commonlib/sendOutput

A.61.1. NAME
A.61.2. SYNOPSIS
A.61.3. FUNCTION
A.61.4. INPUTS
A.61.5. NOTES
A.61.6. SOURCE

A.62. phpcron_commonlib/getProcessInfo()

A.62.1. NAME
A.62.2. SYNOPSIS
A.62.3. FUNCTION
A.62.4. RESULT
A.62.5. SOURCE

A.63. phpcron_commonlibp/isPathbad

A.63.1. NAME
A.63.2. SYNOPSIS
A.63.3. FUNCTION
A.63.4. INPUTS
A.63.5. RESULT
A.63.6. EXAMPLE
A.63.7. SOURCE

A.64. phpcron_commonlib/formatPath

A.64.1. NAME
A.64.2. SYNOPSIS
A.64.3. FUNCTION
A.64.4. PURPOSE
A.64.5. INPUTS
A.64.6. RESULT
A.64.7. NOTES
A.64.8. SOURCE

A.65. phpcron_commonlib/is_email

A.65.1. NAME
A.65.2. SYNOPSIS
A.65.3. FUNCTION
A.65.4. INPUTS
A.65.5. RESULT
A.65.6. BUGS
A.65.7. SOURCE

A.66. phpcron_commonlib/appendToFile

A.66.1. NAME
A.66.2. SYNOPSIS
A.66.3. FUNCTION
A.66.4. INPUTS
A.66.5. RESULT
A.66.6. EXAMPLE
A.66.7. NOTES
A.66.8. SOURCE

A.67. phpcron_commonlib/saveFile

A.67.1. NAME
A.67.2. SYNOPSIS
A.67.3. FUNCTION
A.67.4. INPUTS
A.67.5. RESULT
A.67.6. EXAMPLE
A.67.7. SOURCE

A.68. phpcron_commonlib/deleteFile

A.68.1. NAME
A.68.2. SYNOPSIS
A.68.3. FUNCTION
A.68.4. INPUTS
A.68.5. RESULT
A.68.6. NOTES
A.68.7. SOURCE

A.69. phpcron_commonlib/isInteger

A.69.1. NAME
A.69.2. SYNOPSIS
A.69.3. FUNCTION
A.69.4. INPUTS
A.69.5. RESULT
A.69.6. SOURCE

A.70. phpcron_commonlib/isIntegerInRange

A.70.1. NAME
A.70.2. SYNOPSIS
A.70.3. FUNCTION
A.70.4. INPUTS
A.70.5. RESULT
A.70.6. SOURCE

A.71. phpcron_commonlib/mailAttachment

A.71.1. NAME
A.71.2. SYNOPSIS
A.71.3. FUNCTION
A.71.4. INPUTS
A.71.5. RESULT
A.71.6. EXAMPLE
A.71.7. SOURCE

A.72. phpcron_commonlib/isOtherPhpcrond

A.72.1. NAME
A.72.2. SYNOPSIS
A.72.3. FUNCTION
A.72.4. PURPOSE
A.72.5. RESULT
A.72.6. BUGS
A.72.7. SOURCE

A.73. phpcron_commonlib/stopOtherPhpcron

A.73.1. NAME
A.73.2. SYNOPSIS
A.73.3. FUNCTION
A.73.4. RESULT
A.73.5. SOURCE

A.74. phpcron_commonlib/parseCronTimeParams

A.74.1. NAME
A.74.2. SYNOPSIS
A.74.3. FUNCTION
A.74.4. RESULT
A.74.5. SOURCE

A.75. phpcron_commonlib/isCronTimeParamsBad

A.75.1. SYNOPSIS
A.75.2. FUNCTION
A.75.3. INPUTS
A.75.4. RESULT
A.75.5. SOURCE

A.76. phpcron_commandlib/downloadFile

A.76.1. NAME
A.76.2. SYNOPSIS
A.76.3. FUNCTION
A.76.4. INPUTS
A.76.5. RESULT
A.76.6. EXAMPLE
A.76.7. SOURCE

1. Introduction

  ------------------------------------------------------------------------

1.1. What is Phpcron?

Phpcron is a [7]PHP command line program which allows you to execute
programs and system commands at certain scheduled times. Phpcron operates in
a similar fashion to Unix's Crond daemon, parsing a configuration file
called phpcrontab.conf every minute and determining whether any programs are
schedule to run. If so, Phpcron executes the indicated programs. Phpcron
allows a host of options, including logging and email features.

The Phpcron package also includes Phpcron Admin (phpcron_admin.php) which
provides a browser based interface to Phpcron, allowing a user to remotely
schedule programs and change Phpcron options in a user friendly way without
having to deal with ssh, telnet, or arcane text editors.

  ------------------------------------------------------------------------

1.2. Why Use Phpcron instead of just Unix's Crond?

The primary advantage of using Phpcron is the graphical interface provided
by Phpcron Admin and the additional logging and email features provided by
Phpcron. With Phpcron you can turn email notification of command execution
on or off, logging on or off, and access all the configuration options under
Phpcron Admin. In addition, Phpcron can be used both on Unix and MS Windows'
systems. Phpcron and Phpcron Admin provide an ideal solution for web hosts
who wish to provide a graphical interface with the scheduling power of Crond
and the added feature enhancements provided by Phpcron.

  ------------------------------------------------------------------------

1.3. Copyright Information

This document is copyrighted © 2001 [8]David C. Druffner and is distributed
under the terms of the license, stated below.

This manual may be reproduced and distributed in whole or in part, in any
medium physical or electronic, as long as this copyright notice is retained
on all copies. Commercial redistribution is allowed and encouraged; however,
this copyright notice must appear prominently in the work and this author
would like to be notified at the following email address:
<[9]ddruff@gemini1consulting.com> prior to any such commercial
distributions.

All translations, derivative works, or aggregate works incorporating this
manual must be covered under this copyright notice. That is, you may not
produce a derivative work from this manual and impose additional
restrictions on its distribution. Exceptions to these rules may be granted
under certain conditions; please contact the [10]author.

Modifications: Any significant modifications (anything other than the
correction of typos) to this document must be identified on the title page
in the revision section of this document with the name and contact
information of each author appearing next to each revision.

If you have any questions, please contact [11]David Druffner

  ------------------------------------------------------------------------

1.4. Disclaimer

NO LIABILITY FOR THE CONTENTS OF THIS DOCUMENT CAN BE ACCEPTED. USE THE
CONCEPTS, EXAMPLES AND OTHER CONTENT AT YOUR OWN RISK. THERE MAY BE ERRORS
AND INACCURACIES, THAT MAY OF COURSE BE DAMAGING TO YOUR SYSTEM. PROCEED
WITH CAUTION, AND ALTHOUGH THIS IS HIGHLY UNLIKELY, THE AUTHOR(S) DO NOT
TAKE ANY RESPONSIBILITY FOR THAT.

All copyrights are held by their by their respective owners, unless
specifically noted otherwise. Use of a term in this document should not be
regarded as violating any trademark or service mark.

Naming of particular products or brands should not be seen as endorsements.

  ------------------------------------------------------------------------

1.5. Phpcron License

Phpcron, Phpcron Admin,and associated scripts, carry the following license
which is GPL compatible and modeled on the modified BSD license (for GNU
descriptions of various license types see the [12]GNU License Page):

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2.Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3.The name of the author may not be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
EVENT SHALL THE AUTHOR, ANY DISTRIBUTOR, OR ANY DOWNLOAD HOSTING COMPANY BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

  ------------------------------------------------------------------------

1.6. Manual Version

This document is version 0.5.1.0 The document version number is in S.S.M.M
format. S.S. will always match the version of the software and M.M. will
indicate the release of the manual relating to that version. The latest
version of this document, which will be made available in a variety of
formats, including plain text, HTML (tarred and zipped), Single Html,Adobe
Acrobat PDF, and the SGML source, can be found at the[13] Phpcron Document
Page.

  ------------------------------------------------------------------------

1.7. Credits

I have the pleasure of acknowledging:

  *

    [14]Gemini 1 Consulting, LLC for support during the development of this
    progam and for providing the resources to host the Phpcron's
    documentation page.Gemini 1 Consulting, LLC is the developer of
    GemTrend[tm], a Windows based Building Controls Software application,and
    other innovative software products.

  *

    [15]SourceForge, the host of Phpcron's download and development page.

>

  ------------------------------------------------------------------------

1.8. Feedback

Feedback is most certainly welcome for this document. Without your
submissions and input, this document wouldn't exist. An [16] online manual
is available for you to submit comments for all to read and for
consideration for incorporation into the next version of this manual.

  ------------------------------------------------------------------------

1.9. Translations

Translations of this document are welcome. Please use the SGML Source, or
failing that, the HTML or text version, all of which are found at the
[17]document page. Translations can be emailed to [18]David Druffner.

  ------------------------------------------------------------------------

2. Download Phpcron

The latest version of Phpcron can be found on the Sourceforge [19]Phpcron
Project Page and at [20]Gemini 1 Consulting, LLC. When the package is
uncompressed it should contain the following files:

  *

    phpcron.php (the primary Phpcron script)

  *

    phpcron_admin.php (the Phpcron Admin script

  *

    phpcron_commonlib.php (contains common library functions)

  *

    phpcron_userconfig.php (user configuration file, optional only if you
    don't use Phpcron Admin)

  *

    phpcrontab.conf (sample file which holds scheduling configuration,
    format is similar to Unix crontab)

  *

    phpcrond (Linux bash shell script for invoking Phpcron as a daemon)

  *

    phpcron (Linux bash shell script for invoking phpcron.php)

  *

    phpcron_virtuald (Linux bash shell script for invoking Phpcron as a
    Virtual Daemon - use this on the Unix crontab)

  *

    phpcron_test.sh (a test shell script to put on phpcrontab.conf to test
    execution of Phpcron)

  *

    phpcron_manual_big.html (this Phpcron manual in html)

  *

    phpcron_manual_big.txt (this Phpcron manual in text)

  *

    LICENSE.txt (license, info)

  ------------------------------------------------------------------------

3. System Requirements

  *

    [21]PHP 4 (at least version 4.0.1, it was tested on version 4.0.3pl1 )
    installed as a [22]CGI program which provides a command line
    interpreter. The main engine behind Phpcron and Phpcron Admin is
    phpcron.php, a script run at the command line.

  *

    Operating System. While the emphasis in development of Phpcron has been
    on Unix systems, it will run on Microsoft Windows platforms. However,
    Phpcron Admin will not be able to start the Phpcron Daemon,and the
    Virtual Daemon is designed to work with Unix's Crond.

  *

    The web server must allow system calls.If in safe mode, it won't allow
    this unless the safe mode directory option has been enabled, and then
    only for system calls to commands that are in the safe mode directory.
    See the [23]safemode section of the [24]PHP Manual for details.

  *

    Read/write/execute permissions for the user of the server process ( for
    Apache, usually "nobody", "www", "apache" or "httpd" - do a ps-ef | grep
    httpd to find out) to the directory containing Phpcron,read permissions
    to all files, write permissions to phpcrontab.conf.See Installation for
    details. If you are operating on a remote server you may need telnet
    access to do this, although some ftp clients allow you to set
    permissions.

  ------------------------------------------------------------------------

4. Installation

  *

    Create a new subdirectory in your web server's document root (e.g.,
    phpcron).

  *

    Copy the tar file to the new subdirectory and uncompress it.

  *

    You can optionally place phpcron.php and phpcron_commonlib.php in a
    different directory than phpcron_admin.php. For example, you may wish to
    place those files in your bin directory outside of the web root (so that
    it is within your path and you can execute easily from the command
    line). If you do, you must edit phpcron_admin.php, find the definition
    of the $phpcron_directory variable in the beginning of the script, and
    change it to equal a string which contains the path to the directory
    containing phpcron.php. The variable by default is set to the current
    directory.

  *

    Edit phpcron_commonlib.php, find the definition of the $php_path
    variable in the beginning of the script, and change it to equal a string
    which contains the path to the directory containing the "php" cgi
    executable. This will often be "/usr/local/bin" or "/usr/bin". Do an "ls
    /usr/local/bin/php" or "ls /usr/bin/php" to find out. If you still can't
    find it, check your $PATH environment variable: "echo $PATH" and look in
    all the directories in your path to locate the "php" executable.

  *

    Edit phpcron_virtuald, and change the definition of the
    PHPCRON_DIRECTORYto equal the path to the directory which holds
    phpcron.php. In addition, change the PHP_PATH variable to equal a string
    which contains the path to the directory containing the "php" cgi
    executable (see above).

     [Note] 

    If you are in a Windows environment, path names should be written with a
    forward (/) slash (NOT a backslash or an escaped backslash (\\) ).

  *

    Make sure the web server process has read/write/execute permissions to
    the installation directory, to the web server document root directory,
    phpcrontab.conf, and phpcron_userconfig.php. (Apache's process is
    usually owned by "www", "nobody", "apache" or "httpd").

  *

    Make the installation directory password protected, preferably with ssl
    login only and allow only web and/or system administrators to access
    (see web server documentation). This is crucial as Phpcron allows a user
    to execute system programs!

  *

    Point your browser to phpcron_admin.php. You probably will get some
    errors indicating that it cannot read your output file, log file and/or
    your phpcrontab.conf file. Scroll down until you see the options and
    edit the text boxes for $phpcrontab_filename and $log_result_file to
    point to your main installation directory. You will also want to change
    the email address, and any other appropriate options. Then click on the
    Save button. You may continue to get errors regarding not being able to
    read the output file until you start Phpcron since that file isn't
    created until Phpcron is run at least once.

     [Note] 

    One option you may consider for security reasons is to place your
    phpcrontab.conf file outside of your web root. If you do so you will
    need to change the path of the phpcrontab.conf to point to that
    location.

    For reference, here is a screen shot showing the available options:

    [Image]

  *

    If you are on a Unix/Linux system, and want to utilize the Virtual
    Daemon you need to edit your Unix crontab file. Go to the command prompt
    (if you are installing on a remote system you will need to telnet or ssh
    to the server) and type crontab -e. If your server gives you access to
    crontab, that should put you into vi (or some other text editor) showing
    your Crontab file. Insert the following line (in Vi you insert by typing
    the escape key, then the letter "i", then the text to be inserted):

     

    * * * * * . [full path to phpcron directory]/phpcron_virtuald

    Notice the filename is preceeded by a dot and a space. The dot is the
    bash shell execute command. Many system admins (especially on virtual
    hosts) will require both the dot command, as well as the full path to
    the shell command (even if you would expect it already to be in your
    path). Now save and quit (in Vi this would be the escape key, then
    "ZZ"). This will cause Crond to execute phpcron_virtuald every minute in
    non-daemon mode, which simulates the effect of a Phpcron daemon but
    without its overhead.
  *

    That's it. You can now view output, start and stop daemons (actual and
    virtual), view the log, and set options using the Control Panel. Set the
    schedule of programs using the Edit Schedule (Basic) and Edit Schedule
    (Advanced) menu selections. See the section on Phpcron Admin for
    screenshots and explanations of these options.

  *

    To test your installation, put the phpcron_test.sh script on your
    phpcrontab.conf file. Click on Edit Schedule (Basic) OR Edit Schedule
    (Advanced). For example, if it is Tuesday, enter something like this to
    execute the test script every minute (for more information on
    phpcrontab.conf see Phpcrontab):

     

    * * * * 2 . ./phpcron_test.sh

    Then press Save. This should execute the phpcron_test.sh file every
    minute. This little script creates an HTML file called phpcron_test.html
    and outputs to it the time of the script's execution. To verify that it
    has been executed, make sure that the Phpcron daemon (either actual or
    Virtual) is enabled, wait a minute, then point your browser to
    http://[yoursite]/[phpcron_installation_directory]/phpcron_test.html.
    You should see the HTML page updated every minute with the current time
    when you press reload on your browser.

 [Warning] 

A Note on privileges in Unix: Using chmod and chown, you should make the
owner of the server process a member of a group (say phpcron_group) and
grant that group the necessary privileges to read, write, and execute files
in the phpcron installation directory . All other users should be denied
even read access. These same restrictions should be implemented on a Windows
system using the equivalent permission controls.

 [Note] 

The above instructions assume you are going to use Phpcron Admin with
Phpcron. If you only want to use Phpcron at the command line, just copy
phpcron_commonlib.php, phpcron.php, phpcrontab.conf, and in a Unix
environment, the shell scripts, phpcrond, and phpcron to a directory in your
path, set the proper permissions, and execute with the proper options.

  ------------------------------------------------------------------------

5. Scheduling Program Execution

Phpcrontab.conf is the text file that holds the Phpcron scheduling
directives. An example file is included in your download package. The format
is the same as Crond's crontab. The format is:

 

 minute hour   day of month  month   weekday  command
 (0-59) (0-23)   (1-31)      (1-12)   (0-6)
 

Wild Cards and ranges are allowed. Each parameter is separated by one pace,
except the command text which can be separated from the time parameters by
more than one space. You can use leading zeros (e.g, 03) but it is not
necessary. You can comment to the end of a line by beginning the comment
with a pound sign (#) (shell style comments) but multiple C style (e.g.,
/*comment */) line comments are not allowed.

Example 1. Short Phpcrontab.conf Example

 

 
 # Example phpcrontab.conf file with wildcard. 
 
 # Executes command every Friday at 3:59
 
 59 3 * * 5     sample_script.sh  
 
 # executes on the 1st and 15th of the month
 
 0 0 1,15 * *   sample_script.sh  
 
 #executes on the 1st-15th of the month 
 #which are any weekday except Wednesday and Saturday
 
 0 0 1-15 * 0-2,4,6 sample_script.sh
 

  ------------------------------------------------------------------------

6. Command Line Execution

You don't need Phpcron Admin to invoke Phpcron. Assuming that the Phpcron
scripts are in your path, at your system prompt type

 

php phpcron.php [commandline switches]

To invoke Phpcron as a daemon type the following:

 

php phpcron.php --daemon

On Linux systems, instead of the above, you can use the shell scripts which
are simpler:

 

phpcron [commandline switches]

This executes the bash shell script phpcron which in turns executes
phpcron.php.

For daemon execution in Linux, type

 

phpcrond [command line switches]

 [Note] 

phpcron.php relies on the phpcron_commonlib.php file for certain critical
functions. Thus, while phpcron.php can be executed at the command line
without using Phpcron Admin and without relying on the phpcron_admin.php
script, it must have access to phpcron_commonlib.php file. Make sure that
phpcron_commonlib.php. is in the same directory as phpcron.php.

  ------------------------------------------------------------------------

7. Phpcron Options

There are a host of options to Phpcron - all of which can be set either on
the command line or through Phpcron Admin. To see the entire set of switches
type php phpcron.php -h (or in Linux phpcron -h at the system prompt). Most
of the options have either a long format (using --) or a short format (-).
Some of the more useful options are:

Common Phpcron Command Line Switches

--daemon, -D

    Invokes phpcron as a daemon (runs continuously)

--daemon-off, -d

    Invokes phpcron.php in non-daemon mode. In this mode, it runs once, then
    exits. Usually only used for debugging, also utilized by
    phpcron_virtuald to simulate a daemon.

--email-errors EMAIL_ADDRESS, -E EMAIL_ADDRESS

    Email Errors on - Email failure message if scheduled program fails to
    execute

--mail-notification EMAIL_ADDRESS, -M EMAIL_ADDRESS

    Turn the mail notification feature on

--help, -?, -h

    Help - Gives Explanation of Options

--logging LOGFILE, -L LOGFILE

    Turn logging on and set the path to the log file

--quit, -q

    Stops all instances of the phpcron daemon

 [Note] 

All of the options in phpcron.php have what I call "original" defaults, the
settings of which you can view with the -h switch. However, these are
overridden by the settings in the optional phpcron_userconfig.php file if it
exists in the Phpcron directory. Phpcron_userconfig.php file is also the one
which Phpcron Admin parses, displays, and changes when it changes options.
So if you use Phpcron Admin and change any Phpcron options, the original
defaults will change at the command line. Finally,please note that the
command line switches override both the original defaults and the settings
in the phpcron_userconfig.php file.

  ------------------------------------------------------------------------

8. Phpcron Admin

  ------------------------------------------------------------------------

8.1. Overview

Phpcron Admin is a browser-based interface to Phpcron which allows you to
configure Phpcron's options, stop and start Phpcron, and view the log file.
It is an ideal utility for system administrators to use to allow their
clients to schedule programs in a user friendly manner.

  ------------------------------------------------------------------------

8.2. Control Panel

The Phpcron Admin Control Panel allows you to do the following:

  *

    view status of Phpcron (including PID of any currently running process)

  *

    set all configuration options for Phpcron

  *

    start and stop Phpcron (both in daemon and non-daemon modes)

  *

    enable and disable the Virtual Daemon,

  *

    view,download, and email the phpcron log file

  *

    schedule command execution (either through a direct edit of the
    phpcrontab.conf file or a user friendly form that checks entries for
    correct format)

>

Below is a screenshot, showing a section of the Control Panel. As you can
see, the Virtual Daemon has been enabled.

Example 2. Screenshot: Control Panel (Virtual Daemon Enabled)

[Image]

The control panel also allows you to view and clear the log file, the
Phpcron output, and the programs that are scheduled (the screen shots of
these sections are not shown).

Below is the next section of the Control Panel showing the options that can
be configured for Phpcron. These options mirror the options that can be set
using the command line options.

Example 3. Screenshot: Control Panel Option Configuration

[Image]

 [Note] 

The options above are generated on the fly by parsing the
phpcron_userconfig.php file. This file must exist to run Phpcron Admin (it
is not needed to run the Phpcron on the command line). The options shown
will also change depending on what variables are defined in the
phpcron_userconfig.php file.

  ------------------------------------------------------------------------

8.3. Edit Scheduled Programs

Phpcron Admin also allows you to edit the phpcrontab.conf file and schedule
your programs. This can be done with the "Edit Schedule (Advanced)" screen
which allows you to directly edit the file (you can also edit the Options
directly by selecting the Set Options (Advanced) menu choice).

However, a better (and safer) way to schedule programs is to use the "Edit
Schedule (Basic)" option on the menu. This will present you with a form that
allows you to edit the schedule parameters, and when saved, will validate
the parameters to check that they are in the correct format (a Javascript
validation is used also). Here is a screenshot of a portion of the Edit
Schedule (Basic) screen:

Example 4. Screenshot: Edit Schedule (Basic)

[Image]

As you can see, the top comments of the file are presented in a text box at
the top. There is no need to add leading #, these are added automatically
when the file is saved. The schedule parameters can be entered in time
columns. When the file is saved (the save button is not shown in the
screenshot) the form will be validated (the formats of the time parameters
are checked to see if they are within the correct ranges, etc.)

  ------------------------------------------------------------------------

9. Modes and the Virtual Daemon

  ------------------------------------------------------------------------

9.1. Modes (Daemon and Non-Daemon)

Phpcron can be run in one of two "modes". The first is the "daemon mode" in
which Phpcron runs continuously in the background. This mode is appropriate
for systems in which only one user will be utilizing Phpcron. Unlike Unix's
Crond daemon, a single Phpcron process parses only one configuration file
(phpcrontab.conf) and cannot be configured to parse multiple users'
crontabs. However, Phpcron can be run as a "Virtual Daemon" in conjunction
with Unix's Crond, allowing multiple users on a single system to use Phpcron
and Phpcron Admin.

The second mode that Phpcron can be run in is the "non-daemon mode". This
simply runs the script once and quits. It parses the phpcrontab.conf file
only once. It is not very useful except for testing purposes.

  ------------------------------------------------------------------------

9.2. Virtual Daemon

The real advantage that Phpcron has over Crond is the ability to use Phpcron
Admin - a user friendly web based interface for the various scheduling and
configuration options. However, in order to allow multiple users to use
Phpcron on the same machine (e.g., in a virtual hosting environment) one
would ordinarily need to invoke multiple instances of the Phpcron daemon -
an unacceptable situation since this would overwhelm the server (in fact
Phpcron is written to avoid this situation. It will automatically detect if
another instance of Phpcron is running, and if so, refuse to run in daemon
mode). However, one can allow multiple users utilize Phpcron by running it
as a "Virtual Daemon". Instead of Phpcron running continuously, it is
executed once every minute using Unix's Crond. This is done by putting
editing your crontab file(using crontab -e, see Installation for details).
This will cause Crond to run phpcron_virtuald every minute. phpcron_virtuald
is a shell script wrapper which invokes phpcron.php in non-daemon mode only
if the Virtual Daemon has been enabled by Phpcron Admin.

Phpcron Admin enables the Virtual Daemon by creating the file
phpcron_venabled in the Phpcron directory. Before invoking phpcron.php,
Phpcron_virtuald checks to see if the phpcron_venabled exists.If so, it
executes phpcron.php in non-daemon mode. If the file does not exist,
phpcron_virtuald does nothing. Thus the Virtual Daemon allows you to get the
advantage of using Phpcron without the overhead of actual daemons running in
the background, allowing multiple users on a system to use its features.

  ------------------------------------------------------------------------

10. Code History

0.5b is the first version of Phpcron. It is a beta version.

  ------------------------------------------------------------------------

11. Demo

A Demonstration of Phpcron Admin and Phpcron is available [25] here. Note
that for security reasons, you won't be able to edit any configuration files
and will get error messages saying that the configuration files can't be
written to.

  ------------------------------------------------------------------------

12. Code Contributions

Code modifications and contributions are welcome. Suggestions include:

  *

    Further Testing and improvement on Windows 95/98/NT/2000 (the current
    version has been tested on Windows 95 and Linux only)

>

Please contribute at the Sourceforge [26] Phpcron Project Page

  ------------------------------------------------------------------------

13. Code Reference

The Phpcron scripts have been heavily commented with inline documentation
using a [27]version of Robodoc which this author revised to produce
[28]DocBook SGML. Attached as an Appendix is the documented code for your
reference. Some versions of this document may not have the Appendix, in
which case, you can obtain the full version of the manual with the attached
Appendix at the [29] Phpcron document page.

  ------------------------------------------------------------------------

A. Phpcron Code Reference

Generated from xref_file with ROBODoc v3.2.3 on Wed Oct 24 21:26:43 2001

  ------------------------------------------------------------------------

A.1. Phpcron Source Code Reference

A.1.1. Source Files

A.1.1.1. phpcron.php

  ------------------------------------------------------------------------

A.1.1.2. phpcron_admin.php

  ------------------------------------------------------------------------

A.1.1.3. phpcron_commonlib.php

  ------------------------------------------------------------------------

A.1.2. Functions

A.1.2.1. appendToFile

  ------------------------------------------------------------------------

A.1.2.2. buildNewtab

  ------------------------------------------------------------------------

A.1.2.3. checkPhpVersion

  ------------------------------------------------------------------------

A.1.2.4. clearLogFile

  ------------------------------------------------------------------------

A.1.2.5. cpPhpcron

  ------------------------------------------------------------------------

A.1.2.6. deleteFile

  ------------------------------------------------------------------------

A.1.2.7. downloadFile

  ------------------------------------------------------------------------

A.1.2.8. editTabByForm

  ------------------------------------------------------------------------

A.1.2.9. formatPath

  ------------------------------------------------------------------------

A.1.2.10. fullEditBox

  ------------------------------------------------------------------------

A.1.2.11. getAssignmentInfo

  ------------------------------------------------------------------------

A.1.2.12. getComments

  ------------------------------------------------------------------------

A.1.2.13. getFormElement

  ------------------------------------------------------------------------

A.1.2.14. getProcessInfo()

  ------------------------------------------------------------------------

A.1.2.15. isBadPhp

  ------------------------------------------------------------------------

A.1.2.16. isCronTimeParamsBad

  ------------------------------------------------------------------------

A.1.2.17. isInteger

  ------------------------------------------------------------------------

A.1.2.18. isIntegerInRange

  ------------------------------------------------------------------------

A.1.2.19. isOtherPhpcrond

  ------------------------------------------------------------------------

A.1.2.20. isPathbad

  ------------------------------------------------------------------------

A.1.2.21. isTabFormBad

  ------------------------------------------------------------------------

A.1.2.22. is_email

  ------------------------------------------------------------------------

A.1.2.23. killOtherPhpcron

  ------------------------------------------------------------------------

A.1.2.24. mailAttachment

  ------------------------------------------------------------------------

A.1.2.25. menuBar

  ------------------------------------------------------------------------

A.1.2.26. pageTitle

  ------------------------------------------------------------------------

A.1.2.27. parseCronTimeParams

  ------------------------------------------------------------------------

A.1.2.28. parseUserConfig

  ------------------------------------------------------------------------

A.1.2.29. rebuildUserCfg

  ------------------------------------------------------------------------

A.1.2.30. saveFile

  ------------------------------------------------------------------------

A.1.2.31. sendOutput

  ------------------------------------------------------------------------

A.1.2.32. stopOtherPhpcron

  ------------------------------------------------------------------------

A.1.2.33. stopThisProcess

  ------------------------------------------------------------------------

A.1.2.34. stripPhp

  ------------------------------------------------------------------------

A.1.2.35. tabTopComments

  ------------------------------------------------------------------------

A.1.3. Variables

A.1.3.1. $admin_email_address

  ------------------------------------------------------------------------

A.1.3.2. $admin_subpage

  ------------------------------------------------------------------------

A.1.3.3. $assignment_info

  ------------------------------------------------------------------------

A.1.3.4. $cl_help

  ------------------------------------------------------------------------

A.1.3.5. $daemon_mode

  ------------------------------------------------------------------------

A.1.3.6. $debug

  ------------------------------------------------------------------------

A.1.3.7. $error_email_address

  ------------------------------------------------------------------------

A.1.3.8. $left_mlc_ch

  ------------------------------------------------------------------------

A.1.3.9. $license

  ------------------------------------------------------------------------

A.1.3.10. $log_result

  ------------------------------------------------------------------------

A.1.3.11. $log_result_file

  ------------------------------------------------------------------------

A.1.3.12. $mail_errors

  ------------------------------------------------------------------------

A.1.3.13. $mail_success

  ------------------------------------------------------------------------

A.1.3.14. $phpcron_directory

  ------------------------------------------------------------------------

A.1.3.15. $phpcron_file

  ------------------------------------------------------------------------

A.1.3.16. $phpcron_off

  ------------------------------------------------------------------------

A.1.3.17. $phpcron_output

  ------------------------------------------------------------------------

A.1.3.18. $phpcron_psinfo_file

  ------------------------------------------------------------------------

A.1.3.19. $phpcron_venabled_file

  ------------------------------------------------------------------------

A.1.3.20. $phpcrontab_filename

  ------------------------------------------------------------------------

A.1.3.21. $pid

  ------------------------------------------------------------------------

A.1.3.22. $redirect_output

  ------------------------------------------------------------------------

A.1.3.23. $right_mlc_ch

  ------------------------------------------------------------------------

A.1.3.24. $sc_ch

  ------------------------------------------------------------------------

A.1.3.25. $secure

  ------------------------------------------------------------------------

A.1.3.26. $slow_debug_scroll

  ------------------------------------------------------------------------

A.1.3.27. $start_time

  ------------------------------------------------------------------------

A.1.3.28. $suppress_output

  ------------------------------------------------------------------------

A.1.3.29. $system_name

  ------------------------------------------------------------------------

A.1.3.30. $uc_contents

  ------------------------------------------------------------------------

A.1.3.31. $uc_contents_array

  ------------------------------------------------------------------------

A.1.3.32. $uc_contents_length

  ------------------------------------------------------------------------

A.1.3.33. $user_config_file

  ------------------------------------------------------------------------

A.1.3.34. $viewed_by_browser

  ------------------------------------------------------------------------

A.1.3.35. phpcron_directory

  ------------------------------------------------------------------------

A.1.4. Constants

A.1.4.1. CURRENT_DIRECTORY

  ------------------------------------------------------------------------

A.1.4.2. CURRENT_DIRECTORY

  ------------------------------------------------------------------------

A.1.5. Generic

A.1.5.1. phpcron_admin_readme

  ------------------------------------------------------------------------

A.1.5.2. phpcron_commonlib_readme

  ------------------------------------------------------------------------

A.1.5.3. phpcron_readme

Generated from phpcron.php with ROBODoc v3.2.3 on Wed Oct 24 21:26:43 2001

  ------------------------------------------------------------------------

A.2. PHPCRON/phpcron_readme

  ------------------------------------------------------------------------

A.2.1. NAME

 

 phpcron

  ------------------------------------------------------------------------

A.2.2. DESCRIPTION

 

 This is the scheduling engine and command line utility. 
 It can be controlled by phpcron_admin.php

  ------------------------------------------------------------------------

A.2.3. AUTHOR

 

 David C. Druffner
 ddruff@gemini1consulting.com

  ------------------------------------------------------------------------

A.2.4. COPYRIGHT

 

 COPYRIGHT 2001 (C) David C. Druffner
 ddruff@gemini1consulting.com
 This script is released under a modified BSD License.
 See php phpcron.php -license and LICENSE.txt in download package 
 for full license details

  ------------------------------------------------------------------------

A.2.5. CREATION DATE

 

 October 25, 2001

  ------------------------------------------------------------------------

A.2.6. MODIFICATION HISTORY

 

 October 25, 2001 - first beta release, version 0.5b.

  ------------------------------------------------------------------------

A.2.7. BUGS

 

 Can't startup phpcron or execute most system calls in Windows, 
 although stop and other functions work
 Other Bugs can be reported via the online manual:
 [30]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/

  ------------------------------------------------------------------------

A.2.8. NOTES

 

 This script can be controlled by Phpcron Admin (phpcron_admin.php), 
 a based interface.
 
 The current manual for Phpcron and Phpcron Admin is located at 
 [31]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
 The Home Page is:
 [32]http://phpcron.sourceforge.net/
 Download from the Source Forge Project Page:
 [33]http://www.sourceforge.net/projects/phpcron/

 In-Line Documentation:
 A slightly modified version of ROBODOC is used to

 generate documentation for   this code. I have modified the headers.c file in
 the Robodoc source code to  et  the variable header_markers to equal only

 /*ROBODOC* as the start of a  header  marker - this avoids confusion with other
 strings and comments in PHP  code.   Robodoc is available at
 [34]http://www.xs4all.nl/~rfsber/Robo/robodoc.html

  ------------------------------------------------------------------------

A.3. phpcron/CURRENT_DIRECTORY

  ------------------------------------------------------------------------

A.3.1. NAME

 

 CURRENT_DIRECTORY

  ------------------------------------------------------------------------

A.3.2. DESCRIPTION

 

 Constant which holds the path of the current directory.

  ------------------------------------------------------------------------

A.4. phpcron/phpcron_directory

  ------------------------------------------------------------------------

A.4.1. NAME

 

 phpcron_directory - path that holds include files

  ------------------------------------------------------------------------

A.4.2. DESCRIPTION

 

 This is the directory  that holds the include files.  Must be able to be
 written to by process  running this script. By default this is null thus
 pointing to the same  directory as this script .

  ------------------------------------------------------------------------

A.5. phpcron/$start_time

  ------------------------------------------------------------------------

A.5.1. NAME

 

 $start_time - formatted string hold time script started

  ------------------------------------------------------------------------

A.5.2. DESCRIPTION

 

 String containing time script started.

  ------------------------------------------------------------------------

A.6. phpcron/$phpcrontab_filename

  ------------------------------------------------------------------------

A.6.1. NAME

 

 $phpcrontab_filename - name of phpcrontab.conf file

  ------------------------------------------------------------------------

A.6.2. DESCRIPTION

 

 String - Name of phpcrontab.conf file.

  ------------------------------------------------------------------------

A.7. phpcron/$debug

  ------------------------------------------------------------------------

A.7.1. NAME

 

 $debug - controls debug messages

  ------------------------------------------------------------------------

A.7.2. DESCRIPTION

 

 Boolean - true to see debug messages

  ------------------------------------------------------------------------

A.8. phpcron/$slow_debug_scroll

  ------------------------------------------------------------------------

A.8.1. NAME

 

 $slow_debug_scroll - controlls scroll of debug messages

  ------------------------------------------------------------------------

A.8.2. DESCRIPTION

 

 Int - increase to slow scroll of debug messages

  ------------------------------------------------------------------------

A.9. phpcron/$log_result

  ------------------------------------------------------------------------

A.9.1. NAME

 

 $log_result - controls logging

  ------------------------------------------------------------------------

A.9.2. DESCRIPTION

 

 Boolean - true to log of execution of commands in phpcrontab.conf

  ------------------------------------------------------------------------

A.10. phpcron/$log_result_file

  ------------------------------------------------------------------------

A.10.1. NAME

 

 $log_result_files - path to log file

  ------------------------------------------------------------------------

A.10.2. DESCRIPTION

 

 String - path to log file

  ------------------------------------------------------------------------

A.10.3. NOTES

 

 For Dos, use forward slash only, not double escape

  ------------------------------------------------------------------------

A.11. phpcron/$mail_success

  ------------------------------------------------------------------------

A.11.1. NAME

 

 $mail_success - controls email notificatio

  ------------------------------------------------------------------------

A.11.2. DESCRIPTION

 

 Boolean - set to true to mail user a notification that 
 commands in phpcrontab.conf has been executed successfully

  ------------------------------------------------------------------------

A.12. phpcron/$admin_email_address

  ------------------------------------------------------------------------

A.12.1. NAME

 

 $admin_email_address - address to email phpcron messages to

  ------------------------------------------------------------------------

A.12.2. DESCRIPTION

 

 String - contains email address of administrator

  ------------------------------------------------------------------------

A.13. phpcron/$mail_errors

  ------------------------------------------------------------------------

A.13.1. NAME

 

 $mail_errors - controls mailing of error messages

  ------------------------------------------------------------------------

A.13.2. DESCRIPTION

 

 Boolean - set to true to mail the user an error message
 regarding the failure of a scheduled phpcron command.

  ------------------------------------------------------------------------

A.13.3. NOTES

 

 This does not work for Windows/Dos 

  ------------------------------------------------------------------------

A.14. phpcron/$error_email_address

  ------------------------------------------------------------------------

A.14.1. NAME

 

 $error_email_address- email address to send error messages to

  ------------------------------------------------------------------------

A.14.2. DESCRIPTION

 

 String - address receiving mail sent if $mail_errors 
 set to true to mail the user an error message

  ------------------------------------------------------------------------

A.15. phpcron/$system_name

  ------------------------------------------------------------------------

A.15.1. NAME

 

 $system_name- unique name of system which phpcron.php is running

  ------------------------------------------------------------------------

A.15.2. DESCRIPTION

 

 String - Unique name of system on which the phpscript is used. You can name

 it whatever you want, but I suggest the host name - Used to identify system in 
 email messages

  ------------------------------------------------------------------------

A.16. phpcron/$suppress_output

  ------------------------------------------------------------------------

A.16.1. NAME

 

 $suppress_output- true to suppress all but non-fatal error messages

  ------------------------------------------------------------------------

A.16.2. DESCRIPTION

 

 Boolean - Suppress all non-fatal error messages and other output (including
debugging messages). This overides $debug

  ------------------------------------------------------------------------

A.17. phpcron/$daemon_mode

  ------------------------------------------------------------------------

A.17.1. NAME

 

 $daemon_mode- set to true to run as a daemon

  ------------------------------------------------------------------------

A.17.2. DESCRIPTION

 

 Boolean - when this is set to true, phpcron.php runs in a 
 continuously as a daemon.

  ------------------------------------------------------------------------

A.18. phpcron/stopThisProcess

  ------------------------------------------------------------------------

A.18.1. NAME

 

 stopThisProcess

  ------------------------------------------------------------------------

A.18.2. SYNOPSIS

 

 boolean stopThisProcess(string $stop_message)

  ------------------------------------------------------------------------

A.18.3. FUNCTION

 

 Gracefully stops this script. Time stamps the log file,
 deletes phpcron_psinfo file and exits.

  ------------------------------------------------------------------------

A.18.4. INPUTS

 

 string $stop_message - Message to be output to 
 screen

  ------------------------------------------------------------------------

A.18.5. SOURCE

 

    function stopThisProcess($stop_message) {
    //Graceful Stop
    
    global $log_result;
    global $log_result_file;
    global $pid;
    global $phpcron_off;
    global $phpcron_psinfo_file;
    global $daemon_mode;
    /* Only do this if this process is running as a daemon.
    Don't want to log start/stops if only running once */
    sendOutput($stop_message."\r\n", true);
    
    if($daemon_mode) {
    
      $stop_time= date("m/d/Y").":".date("h:i:s:A");
    
      if ($log_result) {
      $stop_message="
    ***********************************************************
    PHPCRON (DAEMON) $pid Stopped $stop_time
    
    Final Output Message:
    ".strip_tags($stop_message)."
    ***********************************************************
    ";
    
      appendToFile("$stop_message", $log_result_file);
      }
    
      deleteFile($phpcron_off);
    
    }
    
    deleteFile($phpcron_psinfo_file);
    deleteFile("$TEMP_DIR/".basename($phpcron_psinfo_file));
    
    
    
    exit;
    
    }    

  ------------------------------------------------------------------------

A.19. phpcron/killOtherPhpcron

  ------------------------------------------------------------------------

A.19.1. NAME

 

 killOtherPhpcron

  ------------------------------------------------------------------------

A.19.2. SYNOPSIS

 

 boolean killOtherPhpcron(void)

  ------------------------------------------------------------------------

A.19.3. FUNCTION

 

 Kills any other phpcron daemons that may be running.
 This is a non-nice termination and is only used
 when stopOtherPhpcron doesn't work. It actually
 kills the process and does not properly 
 timestamp logs, etc.

  ------------------------------------------------------------------------

A.19.4. NOTES

 

 See stopOtherPhpcron

  ------------------------------------------------------------------------

A.19.5. RESULT

 

 Returns true on success, false on failure.

  ------------------------------------------------------------------------

A.19.6. BUGS

 

 Probably lots due to not testing on any other system.
 Ps command may be different for other systems. 
 Kill process won't work on Windows systems.

  ------------------------------------------------------------------------

A.19.7. SOURCE

 

    function killOtherPhpcron() {
    
            /* Abort Phpcron daemons - not nice*/
            //First try to stop nicely
            if(stopOtherPhpcron()){
            
            return true;
            }
            
          

            exec("ps -C php O p |grep 'phpcron.php.(*['--daemon'|'-D'].*'$|cut -d' ' -f1-4",$output,$result_code);
    
            $i=0;
            //loop through processes and kill them

            while($i<=count($output[$i])-1) { //-1 is don't kill this process
            //Get rid of any spaces and make sure only have one element
            $output[$i]=trim($output[$i]);
            $output_array=explode(" ", $output[$i]);
            $output[$i]=$output_array[0];
    

            //sendOutput("Output: Killing Phpcron daemon process $output[$i]\r\n");
            
            exec("kill -9 $output[$i]",$killoutput, $result_code);
            if ($result_code) {
            //sendOutput("Error: Can't Kill process $output[$i]\r\n");
            return false;
            }
    
            $i++;
            }
    
            return !isotherPhpcrond();
    
    }    

  ------------------------------------------------------------------------

A.20. phpcron/$pid

  ------------------------------------------------------------------------

A.21. phpcron/$cl_help

  ------------------------------------------------------------------------

A.21.1. NAME

 

 $cl_help - command line help string

  ------------------------------------------------------------------------

A.21.2. DESCRIPTION

 

 String - holds command line help

  ------------------------------------------------------------------------

A.21.3. SOURCE

 

    $cl_help="
    --abort
    -a
    

            -Aborts a currently running phpcron daemon - Not Nice. Only use if 
            --quit fails
            
    --phpcrontab PHPCRONTAB_CONF_FILE
    -c PHPCRONTAB_CONF_FILE
    

             -Sets the path for configuration file named as PHPCRONTAB_CONF_FILE
             
    --daemon
    -D
            -Daemon Mode - Run until process is killed
            
    --daemon-off
    -d      
    
            -Daemon Off/Run Once - Parse the phpcrontab file once and stop 
            (original default)
            
    
    --email-errors EMAIL_ADDRESS
    -E EMAIL_ADDRESS
    

            Email Errors on - Email failure message if scheduled program fails to
            execute
            
    --email-errors-off
    -e      
            -Mail Errors Stop - Turn off email of errors (original default)
            
    --help
    -h 
    -? 
    
            -Prints this help
            
    --logging LOGFILE
    -L LOGFILE
    
            -Turn logging on and set the path to the log file
            
    --logging-off
    -l      
            -Stops logging (original default)
            
    --mail-notification EMAIL_ADDRESS
    -M EMAIL_ADDRESS
            
            -Turn the mail notification feature on 
            
    --mail-notification-off
    -m
            - Turn the mail notification feature off (original default)
            
            
    --name SYSTEM_NAME
    -n
            -Set the system same used in mail messages
    
    
    -r [DUMP_FILE]
    

            - Redirect All Output to DUMP_FILE (default file: phpcron_output)
            
    --suppress
    -S
            -Suppress all messages to screen except fatal errors
    
    --suppress-off
    -s
            -Stop Suppression of output (original default, opposite of -S)
            
    --slow-debug SECONDS
    -sd SECONDS
    

            -Slow Debug Scroll - SECONDS is integer by which debug messages are 

            slowed. Increase to slow debug messages when verbosity is turned on
    
    --quit
    -q
            -Stops gracefully all currently running phpcron deamons
    
    --verbose
    -v
    
            -Turn debugging messages on
            
    --verbose-off
    
            -Turn debugging messsages off (original default)
            
            

    NOTE: The actual defaults may be different from the \"original default\" setting

    if the user configuration options have been changed in the script or if a user
    configuration file is being used.
    For more information, see the manual that is packaged with the script.
    
    ";    

  ------------------------------------------------------------------------

A.22. phpcron/$redirect_output

  ------------------------------------------------------------------------

A.22.1. NAME

 

 $redirect_output - if true, directs output to specified file

  ------------------------------------------------------------------------

A.22.2. DESCRIPTION

 

 Redirects all output to specified file

Generated from phpcron_admin.php with ROBODoc v3.2.3 on Wed Oct 24 21:26:43
2001

  ------------------------------------------------------------------------

A.23. PHPCRON/phpcron_admin_readme

  ------------------------------------------------------------------------

A.23.1. NAME

 

 phpcron_admin

  ------------------------------------------------------------------------

A.23.2. AUTHOR

 

 David C. Druffner
 ddruff@gemini1consulting.com

  ------------------------------------------------------------------------

A.23.3. DESCRIPTION

 

 This is the browser based interface to phpcron.php.

  ------------------------------------------------------------------------

A.23.4. COPYRIGHT

 

 COPYRIGHT 2001 (C) David C. Druffner
 ddruff@gemini1consulting.com
 This script is released under a modified BSD License.
 See php phpcron.php -license and LICENSE.txt in download package 
 for full license details

  ------------------------------------------------------------------------

A.23.5. BUGS

 

 Can't startup phpcron or execute most system calls in Windows, 
 although stop and other functions work
 Other Bugs can be reported via the online manual:
 [35]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/

  ------------------------------------------------------------------------

A.23.6. NOTES

 

 This is the browser based interface to phpcron.php.

 The current manual for Phpcron and Phpcron Admin is located at 
 [36]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
 The Home Page is:
 [37]http://phpcron.sourceforge.net/
 Download from the Source Forge Project Page:
 [38]http://www.sourceforge.net/projects/phpcron/

 In-Line Documentation:
 A slightly modified version of ROBODOC is used to

 generate documentation for   this code. I have modified the headers.c file in
 the Robodoc source code to  et  the variable header_markers to equal only

 /*ROBODOC* as the start of a  header  marker - this avoids confusion with other
 strings and comments in PHP  code.   Robodoc is available at
 [39]http://www.xs4all.nl/~rfsber/Robo/robodoc.html

  ------------------------------------------------------------------------

A.24. phpcron_admin/CURRENT_DIRECTORY

  ------------------------------------------------------------------------

A.24.1. NAME

 

 CURRENT_DIRECTORY - constant giving path for current directory
 

  ------------------------------------------------------------------------

A.24.2. DESCRIPTION

 

 Constant containing path for directory of script being executed.  This is

 mainly used to expand directories when paths are sent to the screen and the
 a path  otherwise would have no directory name since it is in the current
 directory. See formatPath
 
  

  ------------------------------------------------------------------------

A.25. phpcron_admin/$phpcron_directory

  ------------------------------------------------------------------------

A.25.1. NAME

 

 $phpcron_directory - path to directory holding phpcron.php  

  ------------------------------------------------------------------------

A.25.2. DESCRIPTION

 

 This is the only variable you need to set after  installing.   Its value is the

 directory in which you put phpcron.php and all supporting  scripts  (other than
 this script, phpcron_admin.php) in the  installation  package,  including
 phpcron_commonlib.php,phpcron_userconfig.php,  and   phpcrontab.conf.

  ------------------------------------------------------------------------

A.26. phpcron_admin/$phpcron_output

  ------------------------------------------------------------------------

A.26.1. NAME

 

 $phpcron_output - name and path of output file

  ------------------------------------------------------------------------

A.26.2. DESCRIPTION

 

 This is the file which all output is redirected when the
 -r flag is used. See $cl_help

  ------------------------------------------------------------------------

A.27. phpcron_admin/$secure

  ------------------------------------------------------------------------

A.27.1. NAME

 

 $secure - set to implement some security features

  ------------------------------------------------------------------------

A.27.2. DESCRIPTION

 

 Make this true to turn on some security features. The
 only thing this does now is turn off the "save as"
 text box on the edit screens

  ------------------------------------------------------------------------

A.28. phpcron_admin/$user_config_file

  ------------------------------------------------------------------------

A.28.1. NAME

 

 $user_config_file - contains path and filename of user configuration
 file

  ------------------------------------------------------------------------

A.29. phpcron_admin/$left_mlc_ch

  ------------------------------------------------------------------------

A.29.1. NAME

 

 $left_mlc_ch - contains beginning characters marking beginning of multiline
                comment 

  ------------------------------------------------------------------------

A.30. phpcron_admin/$right_mlc_ch

  ------------------------------------------------------------------------

A.30.1. NAME

 

 $right_mlc_ch - contains end characters of multiline comment for userconfig parse
 

  ------------------------------------------------------------------------

A.31. phpcron_admin/$sc_ch

  ------------------------------------------------------------------------

A.31.1. NAME

 

 $sc_ch - contains start characters for single line comments, used in userconfig parse
 

  ------------------------------------------------------------------------

A.32. phpcron_admin/$uc_contents

  ------------------------------------------------------------------------

A.32.1. NAME

 

 $uc_contents - contents of $user_config_file

  ------------------------------------------------------------------------

A.32.2. NOTES

 

 See cpPhpcron, parseUserConfig, rebuildUserCfg

  ------------------------------------------------------------------------

A.33. phpcron_admin/$uc_contents_length

  ------------------------------------------------------------------------

A.33.1. NAME

 

 $uc_contents_length - length of $uc_contents

  ------------------------------------------------------------------------

A.34. phpcron_admin/$admin_subpage

  ------------------------------------------------------------------------

A.34.1. NAME

 

 $admin_subpage - main url variable which determines which page to display

  ------------------------------------------------------------------------

A.35. phpcron_admin/clearLogFile

  ------------------------------------------------------------------------

A.35.1. NAME

 

 clearLogFile - clears the log file

  ------------------------------------------------------------------------

A.35.2. SYNOPSIS

 

 boolean  clearLogFile(string $log_result_file);

  ------------------------------------------------------------------------

A.35.3. INPUTS

 

 $log_result_file   - file which phpcron.php logs all execution results to

  ------------------------------------------------------------------------

A.35.4. FUNCTION

 

 Deletes the log file and stamps it with the time
 that it was cleared.

  ------------------------------------------------------------------------

A.35.5. RESULT

 

 Returns true if cleared, false if was not able to be cleared.

  ------------------------------------------------------------------------

A.35.6. SOURCE

 

    function clearLogFile($log_result_file) {

    /* Clears Log file, returns false on success, true and error messages on failure */
    
    $clear_time= date("m/d/Y").":".date("h:i:s:A");
    if(!deleteFile($log_result_file)) {

    $error_messages="Cannot delete $log_result_file - Check path and permissions.<br>";
    } else {
    
    $clear_message="
    ***********************************************************
    PHPCRON Log File Cleared on $clear_time
    
    ***********************************************************
    ";
    
    //append to log file and  get error messages, not success message
    $append_results=appendToFile($clear_message,$log_result_file);
    $append_results[0]="";
    if(trim($append_results)) {
    $error_messages.=implode(" ",$append_results);
    }
    
    
    }

    return $error_messages; //if there are errors, this will return true, if not, false
    
    }    

  ------------------------------------------------------------------------

A.36. phpcron_admin/isBadPhp

  ------------------------------------------------------------------------

A.36.1. NAME

 

 isBadPhp - checks to see if there are any parse errors in a PHP file

  ------------------------------------------------------------------------

A.36.2. SYNOPSIS

 

 mixed  isBadPhp(string $file_contents, string $file_name)

  ------------------------------------------------------------------------

A.36.3. FUNCTION

 

 This functions checks $file_contents to see if it has any PHP errors in it 
 (syntax or otherwise) and returns those errors. It does so by saving a

 temporary  file with file_contents  to the web server document root directory
 and then   opening a url to it. 
 
 This should only be used on files that don't have any output - since it

 assumes  that any  output is an error (i.e., mainly intended to check if the
 syntax of  the included  user configuration file is ok.)

  ------------------------------------------------------------------------

A.36.4. INPUTS

 

 $file_contents - contains contents of $file_name file to be checked for errors
 

 $file_name     - contains full path of an existing file, the contents of which
 are $file_contents
 

  ------------------------------------------------------------------------

A.36.5. PURPOSE

 

 The primary purpose of this function is to make sure that the user 

 configuration file does not have an error in it before it is saved  if it is

 being edited through phpcron_admin. This could happen  if the user mistakenly

 enters erroneous statements - especially  in the free style edit mode. Since
 the userconfiguration file  is included both in phpcron_admin.php and

 phpcron.php  this could have disasterous results unless syntax errors, etc. 
 are anticipated.
 

  ------------------------------------------------------------------------

A.36.6. RESULT

 

 It returns the PHP error messages, if none, returns false.  
 

  ------------------------------------------------------------------------

A.36.7. NOTES

 

 
 This requires the web server to have read/write permissions to the
 web server's root document directory.
 

  ------------------------------------------------------------------------

A.36.8. SOURCE

 

    function isBadPHP($file_contents, $file_name) {
    
    
    global $DOCUMENT_ROOT;
    global $SERVER_NAME;
    global $phpcron_directory;
    
    

    $file_name=$DOCUMENT_ROOT."/".basename($file_name).".tmp.php"; //add temporary extension
    $save_results=saveFile(trim($file_contents), $file_name);
    
    if(!$save_results[0]) { //if not a successful save
    $save_results=implode("",$save_results);
    $error_messages.="Save results: $save_results";
    
    
    $index=2;
     /* $error_messages.="

      Error: Cannot save $file_name, verify permissions allow writing to file.<br>

      Error: Cannot save temporary file - verify permissions allow writing to ".formatPath($phpcron_directory)."<br>";
      */
      while(isset($save_results[$index])) {
      $error_messages.=$save_results[$index];
      $index++;
      }
    
      return $error_messages;
    }
    
    $handle = fopen ("http://$SERVER_NAME/".basename($file_name), "r");
    
    while (!feof($handle)) {
    $contents.=fread($handle,4096);
    
    }
    
    fclose($handle);
    $contents=trim(strip_tags($contents));
    //get rid of reference to temporary file name
    $contents=str_replace ("in ".formatPath($file_name),"", $contents);
    deleteFile($file_name);
    
    /*If the output from the open has any characters in it at
       all we are assuming there are errors*/
    
    if ($contents) {
      return "The following PHP errors are in your file<br>\r\n".$contents;
    } else {
      return false;
    }
    
    
    
    } //end of function    

  ------------------------------------------------------------------------

A.37. phpcron_admin/isTabFormBad

  ------------------------------------------------------------------------

A.37.1. NAME

 

 isTabFormBad - validates phpcrontab.conf created by editTabByForm function

  ------------------------------------------------------------------------

A.37.2. SYNOPSIS

 

 boolean isTabFormBad (array $ct_param, array $commands)

  ------------------------------------------------------------------------

A.37.3. FUNCTION

 

 This functions checks $ct_param and $commands which are generated by
 editTabByForm  they conform with proper crontab format. 

  ------------------------------------------------------------------------

A.37.4. INPUTS

 

 $ct_params - 2 dimensional array which contains scheduling parameters for 
              phpcrontab.conf.
 
 $commands   - array which contains scheduled phpcrontab commands. 

  ------------------------------------------------------------------------

A.37.5. RESULT

 

 It returns true if there is a validation error, false if the phpcrontab
 contents are valid.

  ------------------------------------------------------------------------

A.37.6. NOTES

 

 See editTabByForm.

  ------------------------------------------------------------------------

A.37.7. SOURCE

 

    function isTabFormBad($ct_param, $commands) {

    /* Validate parameters in Chron Tab Form Submitted from Structured Edit */
    
    $command_number=0;
    
              /* Cycle through each parameter */
                 while (list($first, $second) = each($ct_param)) {
                  $command_number++;
                  while (list($each_second) = each($second)) {
    

                          $test_value=trim($ct_param[$first][$each_second]);
                         $commands[$first]=trim($commands[$first]);
    

                         /* If it's an asterisk than it's ok - continue to next value */
    
                         if ($test_value =="*") {
                           continue;
                         }
                  }
    
    

                         /* If either there are any parameters for this line or

                         there are commands for this line than validate each parameter
                         for correct format */
    

                         //test if either a time parameter or commands are entered

                         $test_whole_string=trim(implode(" ",$ct_param[$first]));
                         
                         if ($test_whole_string or $commands[$first]) {
    

                         $error_messages.=isCronTimeParamsBad($test_whole_string, $command_number);
                         }
                          
        
                       
                       
                }
                

                /* If there are time parameters and no commands than give error */

                if (trim(implode("",$ct_param[$first])) and !$commands[$first])  {
      

                $error_messages.="Error in Command #$command_number: The commands field is empty<br>";
      
                }
    
              
              if ($error_messages) {

                return "<h3>Cannot save because of validation errors - please fix and try again:</h3>
                      $error_messages";
              } else {
                return false;
              }
    
    }

  ------------------------------------------------------------------------

A.38. phpcron_admin/menuBar

  ------------------------------------------------------------------------

A.38.1. NAME

 

 menuBar

  ------------------------------------------------------------------------

A.38.2. SYNOPSIS

 

 string menuBar(void)

  ------------------------------------------------------------------------

A.38.3. FUNCTION

 

 Contains the HTML for the main navigational menu bar

  ------------------------------------------------------------------------

A.38.4. INPUTS

 

  ------------------------------------------------------------------------

A.38.5. RESULT

 

 Returns a formatted string containing HTML for the menu bar.

  ------------------------------------------------------------------------

A.38.6. SOURCE

 

    function menuBar() {
    global $PHP_SELF;
    
    
      //Print Horizontal Menu Bar
    $output="
      <!--**********Begin Menu Bar**************-->

      <table border=\"0\" cellspacing=\"0\" cellpadding=\"1\" align=\"center\" width=\"800px\" class=\"menuBar\" bgcolor=\"#9999CC\" summary=\"Menu Bar\">
      <tr>
        <td align=\"center\" width=\"25%\">

          <a href=\"$PHP_SELF?admin_subpage=Control_Panel\" title=\"Turn ON/OFF, Set Options\">Control Panel</a>
        </td>
        <td>
        |
        </td>
        <td align=\"center\" width=\"25%\">

          <a href=\"$PHP_SELF?admin_subpage=Edit_UC_Full\" title=\"Directly Edit Options\">Set Options (Advanced)</a>
        </td>
        <td>
        |
        </td>
        <td align=\"center\" width=\"25%\">

          <a href=\"$PHP_SELF"."?admin_subpage=Edit_Tab_By_Form\" title=\"Form Edit of Phpcrontab\">Edit Schedule (Basic)</a>
        </td>
        <td>
        |
        </td>
        <td align=\"center\" width=\"25%\">

          <a href=\"$PHP_SELF?admin_subpage=Edit_Tab_Full\" title=\"Directly Edit Phpcrontab\">Edit Schedule (Advanced)<br></a>
        </td>
      </tr>
      
      </table>
      <!--**********End Menu Bar**************-->
      ";
    
    return $output;
        
    
    }    
    

  ------------------------------------------------------------------------

A.39. phpcron_admin/pageTitle

  ------------------------------------------------------------------------

A.39.1. NAME

 

 pageTitle

  ------------------------------------------------------------------------

A.39.2. SYNOPSIS

 

 string pageTitle(string $title)

  ------------------------------------------------------------------------

A.39.3. FUNCTION

 

 Completes the header for the HTML page inserting the page title, ending title
 and head ta and creating the opening body tag

  ------------------------------------------------------------------------

A.39.4. INPUTS

 

 $title - string containing the title of the HTML page

  ------------------------------------------------------------------------

A.39.5. RESULT

 

 Returns a formatted string containing HTML for the end of the <head> and 
  beginning of the body tag

  ------------------------------------------------------------------------

A.39.6. SOURCE

 

    function pageTitle($title) {
      return "
      $title
      </title>
      </head>
      <body>
      
    <!--Begin Note for Non Compliant Browsers |*-->
    
          <p class=\"ahem\" > 
        <font size=2px> 
        <strong> 
        <em>

              For a better viewing experience, either turn your CSS stylesheets

            on in your browser, or if your browser does not support stylesheets, 
          <a href=\"http://www.webstandards.org/upgrade/\"

            title=\"Download a browser that complies with Web standards.\">download </a> a

            browser that complies with web standards. Some browsers disable stylesheets when
            JavaScript is disabled. 
        </em>
        </strong>    
        </font>
          </p>
    
          <NOSCRIPT>

              <p class=type1>  <font size=2px> <strong> <em> Either you have JavaScript
           turned off in your browser or your browser does not

               support JavaScript. Although this site supports non-JavaScript browsers,

               for better functionality you may want to <a href=\"http://www.webstandards.org/upgrade/\"

              title=\"Download a browser that complies with Web standards.\">download </a>
           a JavaScript enabled browser.
              </em> 
           </strong>
           </font>
              </p><br/>
           </NOSCRIPT>
    
    <!--End Note for Non Compliant Browsers *|-->
        ";
    }    

  ------------------------------------------------------------------------

A.40. phpcron_admin/buildNewtab

  ------------------------------------------------------------------------

A.40.1. NAME

 

 buildNewtab

  ------------------------------------------------------------------------

A.40.2. SYNOPSIS

 

 string buildNewtab(int $max_line_number, string $phpcrontab_filename, array
 $ct_param, array $commands, array $side_line_comments);
 

  ------------------------------------------------------------------------

A.40.3. FUNCTION

 

 Takes information from editTabByForm and creates new file contents to be 
 saved over phpcrontab.conf

  ------------------------------------------------------------------------

A.40.4. INPUTS

 

 int $max_line_number           - max number of lines in file
 string $phpcrontab_filename   - filename of phpcrontab.conf
 array $ct_param                - array containing scheduling parameters
 array $commands                - array containing comments
 array $side_line_comments      - array containing single line # comments 

  ------------------------------------------------------------------------

A.40.5. RESULT

 

 Returns a string containing the contents of the new phpcrontab.conf file

  ------------------------------------------------------------------------

A.40.6. NOTES

 

 See editTabByForm

  ------------------------------------------------------------------------

A.40.7. SOURCE

 

    function buildNewtab($max_line_number, $phpcrontab_filename, $ct_param, $commands, $side_line_comments, $top_line_comments, $bottom_line_comments) {
      
        global $PHP_SELF;
    
         $line_number=0;

         /* Get rid of # as first character of each line (in case user inserted it) */

         $top_line_comments=preg_replace("/^#/m", "", trim($top_line_comments));
         /* Inserts # as first character of each line */

         $top_line_comments=preg_replace("/^(.)/m", "#\\1", trim($top_line_comments));

          $bottom_line_comments=preg_replace("/^#/m", "", trim($bottom_line_comments));

         $bottom_line_comments=preg_replace("/^(.)/m", "#\\1", trim($bottom_line_comments));
    
         $new_tab_contents.=$top_line_comments."\r\n\r\n";
    
            while($line_number< $max_line_number) {
    
                    if($ct_param[$line_number]) {
                        $parameters=implode(" ", $ct_param[$line_number]);

                        $new_tab_contents.=$parameters." ".$commands[$line_number];
                        if($side_line_comments[$line_number]) {

                          $side_line_comments[$line_number]=preg_replace("/^#/m", "", trim($side_line_comments[$line_number]));

                          $side_line_comments[$line_number]=preg_replace("/^(.)/m", "#\\1", trim($side_line_comments[$line_number]));   

                        $new_tab_contents.="  ".$side_line_comments[$line_number]."\r\n";
                        } else {
                        $new_tab_contents.="\r\n";
                        } 
                   }
    
              $line_number++;  
            }
          
            $new_tab_contents.="\r\n\r\n".$bottom_line_comments;
            
            return trim($new_tab_contents); //contents of file to be saved
            
           
    }    

  ------------------------------------------------------------------------

A.41. phpcron_admin/cpPhpcron

  ------------------------------------------------------------------------

A.41.1. NAME

 

 cpPhpcron

  ------------------------------------------------------------------------

A.41.2. SYNOPSIS

 

 void cpPhpcron ([string $phpcron_command]) 

  ------------------------------------------------------------------------

A.41.3. FUNCTION

 

 Displays control panel page controlling activity of phpcron.php

  ------------------------------------------------------------------------

A.41.4. INPUTS

 

 string $phpcron_command - option argument which determines which command
                           to pass to phpcron (see switch statement)

  ------------------------------------------------------------------------

A.41.5. RESULT

 

 Echoes the control panel page to the screen

  ------------------------------------------------------------------------

A.41.6. SOURCE

 

      
    function cpPhpcron ($phpcron_command="default") {
      global $PHP_SELF;
    
      global $phpcron_file;
      global $phpcron_off;
      global $phpcron_psinfo_file;

      global $assignment_info,$user_config_file, $left_mlc_ch, $right_mlc_ch, $sc_ch, $uc_contents_length;
      global $uc_contents, $uc_contents_length;
      global $cp_left_col;
      global $cp_right_col;
      global $cp_row_title;
      global $cp_title;
      global $status_on;
      global $status_off;
      global $status_venabled;
      global $phpcrontab_filename;
      global $log_result_file;
      global $admin_email_address;
      global $system_name;
      global $daemon_mode;
      global $phpcron_venabled_file;
      global $enable_virtual_daemon;
      global $phpcron_output_file;
      global $admin_email_address;
      global $error_messages;
      global $php_path;
    
       echo pageTitle("PHPCRON Admin - Control Panel");
    
    
      switch ($phpcron_command) {
    
      case "VStop":
    
        /* Disable Virtual Daemon */
             
        if (file_exists($phpcron_venabled_file)) {
             
        
        deleteFile($phpcron_venabled_file);
        
        appendToFile("
    ****************************************************************
    PHPCRON Virtual Daemon Stopped ".date("m/d/Y").":".date("h:i:s:A")."
    ****************************************************************
    ", $log_result_file);
    
     
        
        
        }
    
        break;
        
        case "DStop":
    
        /* Turn off Daemon */
        
        if(!stopOtherPhpcron()) {
         $error_messages.="

        Error: Cannot Stop Phpcron. Make sure the server process can write to ".dirname($phpron_off)."<BR>";
        
        }
      
        
        break;
    
      case "Start":
    
    
     
         $os_formatted_path=formatPath($phpcron_file);
    
      
              if ($enable_virtual_daemon) { 
    
        /*Enable Virtual Daemon */
    

            /* If no perpetual loop just write "VIRTUAL DAEMON ENABLED" to phpcron_venabled_file. This will

            allow phpcron to be run from the unix crontab with the phpcron_virtuald script. 
             */
             
    
    

           $save_results=saveFile("VIRTUAL DAEMON ENABLED", $phpcron_venabled_file);
                appendToFile("
    ****************************************************************
    PHPCRON Virtual Daemon Started ".date("m/d/Y").":".date("h:i:s:A")."
    ****************************************************************
    ", $log_result_file);
    
    
    

            if(!$save_results[0]) { //if not a successful save get error messages
    
            $index=1;
            $output="";
            while($save_results[$index]) {
            $output.=$save_results[$index];
            $index++;
            }
    
    
        $error_messages.=implode("\r\n",$save_results).

    "Cannot Enable Virtual Daemon- Must be able to write to ".formatPath($phpcron_venabled_file)." in order for PHPCRON Admin

    to control PHPCRON's execution. You will need to fix, and try again for PHPCRON Admin to work properly.<br>\r\n";
    
            } else {
            

           $error_messages.="The Virtual Daemon has been enabled. Make sure you place phpcron_virtuald
           on your unix crontab file using crontab -e.\n";
    
    
    
          }
    
            break;
        }
        

        /* Otherwise Start Up PHPCRON.PHP in either daemon(perpetual) or non-daemon mode) */
             
         if(isOtherPhpcrond() and $daemon_mode) { 

                $error_messages.="PHPCRON is already running in daemon mode - Cannot start more than one instance<br>";
    
         } else {
    

          /*Start phpcron in background. NoHup allows it to continue after logout */
    
       
          if ($daemon_mode) {

          $exec_string="nohup $php_path $os_formatted_path -r $phpcron_output_file > /dev/null &";
                } else {

          $exec_string="$php_path $os_formatted_path -r $phpcron_output_file";
                   
          }
          //$error_messages.=$exec_string;
           exec($exec_string);
    
    
          sleep(1);    
    
          
          
          if (!$daemon_mode) {
          $error_messages.="Ran PHPCRON only once. This is usually only 
          done for testing purposes.<br>\n";
          
          } 
          
        } 
          

              /* Know there's an error somewhere if the output file can't be made */
             
                if (!file_exists("$phpcron_output_file")) {
    
                 $error_messages.= "

                      Error: Failed to execute $phpcron_file. Check path and permissions. Can't read $phpcron_output_file.
                      <br>
                      ";
                }
    
    
    
    
      // } /* DCD Fix don't use this
        break;
    
    
      case "Email_Log":
    
      $attachment=$log_result_file;
      $mimetype="text/english";
    
      $subject="$system_name PHPCRON Log File Attached";
      $body="PHPCRON Log file is attached for $system_name";
    

    if($mailserver_error=mailAttachment($log_email_address, $subject, $body, $attachment, $mimetype)) {
    
    

      $error_messages.="Error: Unable to Email Log File:<br>\r\n".$mailserver_error;
      } else {
      $error_messages.="Emailed Log File to $admin_email_address";
      }
    
      break;
      
      
      
    
     case "Delete_Log":
       $error_messages.=clearLogFile($log_result_file);
       break;
    
    
    
      case "Save_UC":
    
    

        list($uc_contents, $uc_contents_array)=parseUserConfig($user_config_file, $left_mlc_ch, $right_mlc_ch, $sc_ch);
    
        /* For Debugging (echo to screen instead of save):

        echo "File Rebuilt is: ".nl2br(htmlentities(rebuildUserCfg($assignment_info, $uc_contents_array)))."<br>";
    
        */
    
        /* Rebuild User Configuration File, then Save it */
    

          $save_results=saveFile(rebuildUserCfg($assignment_info, $uc_contents_array), $user_config_file);
    
            if($save_results[0]) { //this would be successful save
        
            $settings_state="
            <em>
            Options saved with the following settings:
            </em>
            <br>
            ";
          } else {
            $index=1;
            while($save_results[$index]) {
            $error_messages.=$save_results[$index];
            $index++;
            }
            $element=0;
            $tab_save_error=true;
            $error_messages.="Please fix and try again.<br>";
    
    
          }
    
         
    
      
        //Load Newly Saved File
    
        $uc_contents = addslashes(implode ("", file ($user_config_file)));
        $uc_contents_length=strlen($uc_contents);  
        

        /* Include new values to override old values included at top of file */
        include($user_config_file); 
      //no break - just let it flow into default
    
      default:
      break;
    }
    
      
      /* Build Main Control Panel Box */
    
      $output.=    "
        <!--**********Begin JavaScript*******************-->
        <SCRIPT LANGUAGE=\"JavaScript\" type=\"text/javascript\">
         <!--  
    
    
       function isNumber(theField) {
       string=theField.value;
        for (i = 0; i < string.length; i++)   {   
              // Check that each character is number.
              var c = string.charAt(i);
      
              if (!((c >= \"0\") && (c <= \"9\")))  {
            
            alert(\"This field requires a number.\");
            theField.focus();
            return false;
            }
          }
         return true;
       }
    
        -->    
    
        </SCRIPT>
        <!--**********End JavaScript*******************-->
    
      <!--**********Begin Control Panel Table**************-->

      <table align=\"center\" border=\"0\" class=\"control_panel\" cellpadding=\"2\" cellspacing=\"0\" width=\"600px\" summary=\"Control Panel\">
            <tr>

            <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_title>
                    <strong>PHPCRON CONTROL PANEL</strong>
            </td>
          </tr>
          <tr>

              <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <strong>Status</strong>
              </td>
          </tr>
          <tr>
            <td style=$cp_left_col>
              Server OS:
            </td>
            <td style=$cp_right_col>
                ".PHP_OS."
            </td>
            </tr>
            ";
    
      if (isOtherPhpcrond()) {
    
      $daemon_running=true;
      }
      
      $output.="
            <tr>
              <td style=$cp_left_col>
                Mode:
              </td>
              ";
      if ($daemon_mode) {
        $output.="
             <td style=$cp_right_col>
                Daemon
              </td>
              </tr>
              ";
        
      } else {
      
       $output.="<td style=$cp_right_col>
                Non-Daemon
              </td>
              </tr>
              ";  
        
      }
      
        $output.="
    
            <tr>
              <td style=$cp_left_col>
                Daemon Running ?
              </td>
              ";
      
              
      if($daemon_running) {
      $output.="
              <td style=$status_on>
                Yes
              </td>
            </tr>";
            
    
      } else {
      
        $output.="
              <td style=$status_off>
                No
              </td>
            </tr>";
              
      
      
      }
    
    
      //Echo Process Info if in Unix
      if(!MS_WINDOWS and file_exists($phpcron_psinfo_file)) {
    
            $file_contents=file($phpcron_psinfo_file);
    
              $output.= "
                  <tr>
                  <td style=$cp_left_col>
                     Owner:
                   </td>
                  <td style=$cp_right_col>
                      $file_contents[1]<br>
                  </td>
                </tr>
                <tr>
                  <td style=$cp_left_col>
                     Process Id:
                   </td>
                  <td style=$cp_right_col>
                      $file_contents[2]
                      <br>
                      <br>
                  </td>
                </tr>
                ";
    
        }
    
      $output.="
        <tr>
            <td valign=\"baseline\" style=$cp_left_col>
              Start/Stop Controls:
            </td>
              ";
      
      if (MS_WINDOWS){
      if (!$daemon_running) {
      $output.="
         <td style=$cp_right_col>
      Start Control Not Available in Windows
      </td>
      </tr>
      <tr>";
      }
      
         

      $end_output .= "Please note that PHPCRON Admin does not allow starting PHPCRON under any Microsoft

      operating system (this may be fixed in a future version).  If using PHPCRON on a remote server, you 

      will need to start PHPCRON through a telnet session. A start control will only appear and work under Unix.
      You can however, enable the Virtual Daemon
      <br>
      ";
      }
    
      
    
      
     
      if (!MS_WINDOWS and $daemon_mode and !$daemon_running) {  
          $output.="
          <td style=$cp_right_col>
          <form action=$PHP_SELF method=\"get\">
          <input type=\"hidden\" name=\"phpcron_command\" value=\"Start\">
          <input type=\"submit\" value=\"Start Daemon\">
            </form>
            </td>
          ";
          
      } elseif (!MS_WINDOWS and !$daemon_mode and !$daemon_running) {
      
      $output.="
      
          <td style=$cp_right_col>
          <form action=$PHP_SELF method=\"get\">

            <input type=\"hidden\" name=\"phpcron_command\" value=\"Start\">
            <input type=\"submit\" value=\"Run PHPCRON Once\">
            </form>
            </td>
          ";
      
       
      }
    
      
     if ($daemon_running) {
    
     $output.="
             <td style=$cp_right_col>
            <form action=\"$PHP_SELF\" method=\"get\">

            <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

            <input type=\"hidden\" name=\"phpcron_command\" value=\"DStop\">
            <input type=\"submit\" value=\"Stop Daemon\">
            </form>
            </td>        
            ";
    
    }
    
    
      $output.="  
            </tr>
            <tr>

              <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <strong>Virtual Daemon</strong>
              </td>
          </tr>    
      
            <tr>
              <td style=$cp_left_col>
                Virtual Daemon:
              </td>
              ";
      
      
      if (file_exists($phpcron_venabled_file)) {
          $output.="
              <td style=$status_on >
                Enabled
             </td>
            </tr>
            ";
       
      } else {
          $output.="
              <td style=$status_off >
                 Disabled
              </td>
            </tr>
            ";
      }
    
    
    
    if (file_exists($phpcron_venabled_file)) {
    
     
      $output.="
            <tr>
            <td style=$cp_left_col>
            &nbsp;
            </td>
            <td style=$cp_right_col>    
            <form action=\"$PHP_SELF\" method=\"get\">

            <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

            <input type=\"hidden\" name=\"phpcron_command\" value=\"VStop\">
            <input type=\"submit\" value=\"Disable\">
            </form>
            </td>
            
            ";
    
    } else {
    
        $output.="
          <tr>
          <td style=$cp_left_col>
            &nbsp;
          </td>
        
          <td style=$cp_right_col>    
          <form action=$PHP_SELF method=\"get\">

          <input type=\"hidden\" name=\"phpcron_command\" value=\"Start\">       

          <input type=\"hidden\" name=\"enable_virtual_daemon\" value=\"true\">   
          <input type=\"submit\" value=\"Enable\">
            </form>
            </td>
            
          ";
    
    
    }
    
    
    
      /* Save and Reset of Options */
    
    
        //allow to revert to original file
      $output.="
    
          </tr>
                    <tr>

              <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <strong>Update Status</strong>
          </td>
          </tr>    
          <tr>
                    <td style=$cp_left_col>
                        &nbsp;
                    </td>
                    <td style=$cp_right_col>
                    <form action=\"$PHP_SELF\" method=\"post\">
                    <input type=\"submit\" value=\"Update\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">
                    </form>
    
                    <!--************Begin Options Form************ -->
    
    
                    </td>
    
          </tr>
    
    
          ";
    
         //Save Options
    
    
      /* Build Options Box */
    
         if($phpcron_command != "Save_UC") {
    
          $settings_state="
            <em>
            Current Settings:
            </em>
            <br>";
         }

        /*Separate out Multi-Line Comments, Single Line Comments, and Executable Portions of
        file into identifiable arrays stored in $uc_contents_array */

        list($uc_contents, $uc_contents_array)=parseUserConfig($user_config_file, $left_mlc_ch, $right_mlc_ch, $sc_ch);
    
    

        //Split up executable string into ordered arrays containing variable, value, and type of variable
    
          if($assignment_info=getAssignmentInfo($uc_contents_array)){
    
            $options_output.="
            <tr>

              <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <form action=\"$PHP_SELF\" method=\"post\">
                  <strong>Options</strong>
                  <br>
                  (Set in ".formatPath($user_config_file).
          ")<br>
                  $settings_state
              </td>
    
            ";
    
    
          $horiz_pos=0;
          while($horiz_pos<$uc_contents_length) {
    
          $i=0;
            while($assignment_info[$horiz_pos][$i]["variable"]) {
                $cell_width="400px";
    
                $options_output.="
                </tr>
                <tr>
                   <td style=$cp_left_col width=\"$cell_width\">".
                    $assignment_info[$horiz_pos][$i]["variable"].
                    " (".$assignment_info[$horiz_pos][$i]["type"].
                    "):".
                  "</td>

                  <td style=$cp_right_col width=\"$cell_width\" valign=\"middle\">".

                    getFormElement($assignment_info[$horiz_pos][$i]["variable"], $assignment_info[$horiz_pos][$i]["value"], $assignment_info[$horiz_pos][$i]["type"], $horiz_pos, $i)."

                    <input type=\"hidden\" name=\"assignment_info[$horiz_pos][$i][variable]\" value=\"".$assignment_info[$horiz_pos][$i][variable]."\">
                    

                      <input type=\"hidden\" name=\"assignment_info[$horiz_pos][$i][type]\" value=\"".$assignment_info[$horiz_pos][$i]["type"]."\">
    
                  </td>
                ";
                $i++;
    
            }
          $horiz_pos++;
          }
            $options_output.=
            "
    

               <!--*****************Begin Submit Buttons *********************-->
             <tr>
                  <td style=$cp_left_col>
                  <HR>
                  </td>
                  <td style=$cp_right_col>
                  <HR>
                  </td>
             </tr>
    
    
             <tr>
              <td style=$cp_left_col>
              Save Changes To Options:
              </td>
              <td style=$cp_right_col>
    
              <input type=\"submit\" value=\"Save\">

              <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

              <input type=\"hidden\" name=\"phpcron_command\" value=\"Save_UC\">
              </form>
              </td>
            </tr>
    
               <tr>
                    <td style=$cp_left_col >
                        Reset Options to Values in File:
                    </td>
                    <td style=$cp_right_col>
                    <form action=\"$PHP_SELF\" method=\"get\">
                    <input type=\"submit\" value=\"Reset\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">
                    </form>
                    </td>
    
               </tr>
    

              <!--*****************End Submit Buttons *********************-->
    
    
    

             <!--*************************BEGIN PHPCRONTAB DISPLAY IN TEXT AREA*********************-->
            <tr>
    

                   <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <strong>PHPCRONTAB SCHEDULE </strong>
                  </td>
            </tr>
            <tr>
    
    
                <td style=$cp_right_col colspan=\"2\" >
                    <form name=\"po_form\">
                      <input type=\"hidden\" name=\"focushere\">

                          <textarea readonly  onFocus=\"this.blur();\" wrap=\"off\" cols=\"80\" rows=\"20\" name=\"command_output_textarea\">";
    
                          //Read from phpcrontab file

                          $path_errors=isPathBad($phpcrontab_filename,true,true); 
                            if ($path_errors) {

    //                      $error_messages.="Error: Unable to read file ".formatPath($phpcrontab_filename)."<br>";
    

                            while ( list($file_or_dir, $error_string) = each($path_errors)) {
    

                              while (list($each_error)  = each($error_string)) {

                                $error_messages.=$path_errors[$file_or_dir][$each_message];
                              }
                             }
                             }
    

                              $tab_output=explode("<br>","ERROR: CANNOT DISPLAY PHPCRONTAB\n ");
                            if (is_readable($phpcrontab_filename)) {
                              $tab_output=file($phpcrontab_filename);
                           }
    
                          $options_output.=implode("",$tab_output)."
                        </textarea>
                    </form>
                </td>
            </tr>
    

             <!--*************************END PHPCRONTAB DISPLAY IN TEXT AREA*********************-->
    
    

               <!--*****************Begin Submit Buttons *********************-->
             <tr>
    
                  <td style=$cp_right_col colspan=\"2\">
                  <HR>
                  </td>
             </tr>
    
    
    
             <tr>
             <!--
                    <td style=$cp_left_col >
                        Edit Schedule (Basic):
                    </td>
            -->
                    <td style=$cp_right_col colspan=\"2\">
                    <form action=\"$PHP_SELF\" method=\"get\">
                    <input type=\"submit\" value=\"Edit Schedule (Basic)\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Edit_Tab_By_Form\">
                    </form>
                    </td>
    
               </tr>
               <tr>
    
                  <td style=$cp_right_col colspan=\"2\">
                  <HR>
                  </td>
             </tr>
    
    

              <!--*****************End Submit Buttons *********************-->
    
    
    

        <!--*************************BEGIN PHPCRON OUTPUT DISPLAY IN TEXT AREA*********************-->
            <tr>
    

                   <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <a name=\"Output_Display\">
                  <strong>PHPCRON OUTPUT </strong>
                  </a>
                  </td>
            </tr>
            <tr>
    
    
                <td style=$cp_right_col colspan=\"2\" >
                    <form name=\"po_form\">
                      <input type=\"hidden\" name=\"focushere\">

                          <textarea readonly  onFocus=\"this.blur();\" wrap=\"off\" cols=\"80\" rows=\"20\" name=\"command_output_textarea\">";
    
                          //Read from phpcron_output file

                          if ($path_errors=isPathBad("$phpcron_output_file",true,true)) {
    

                           $error_messages.="Error: Unable to read output file ".formatPath("$phpcron_output_file")."<br>";
    

                            while ( list($file_or_dir, $error_string) = each($path_errors)) {
    

                              while (list($each_error)  = each($error_string)) {

                                $error_messages.=$path_errors[$file_or_dir][$each_error];
                              }
                             }
                    

                              $command_output=explode("<br>","ERROR: CANNOT DISPLAY PHPCRON OUTPUT\r\nCannot Read Output File $phpcron_output_file\n ");
                            
                           } else {
                              $command_output=file("$phpcron_output_file");
                           }
    
                          $options_output.=implode("",$command_output)."
                        </textarea>
                    </form>
                </td>
            </tr>
    

             <!--*************************END PHPCRON OUTPUT DISPLAY IN TEXT AREA*********************-->

             <!--*************************BEGIN SUBMIT BUTTONS ****************************-->
             <tr>
                    <td style=$cp_right_col colspan=\"2\">

                    <form action=\"$PHP_SELF#Output_Display\" method=\"post\">
                    <input type=\"submit\" value=\"Update Display\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">
                    </form>
                    </td>
    
              </tr>

              <!--*************************END SUBMIT BUTTONS ****************************-->
    

          <!--*************************BEGIN PHPCRON LOG DISPLAY IN TEXT AREA*********************-->
            <tr>
    

                   <td align=\"center\" valign=\"middle\" colspan=\"2\" style=$cp_row_title>
                  <a name=\"log_display\">
                  <strong>PHPCRON COMMAND LOG </strong>
                  </a>
    
                  </td>
            </tr>
            <tr>
    
    
    
                <td style=$cp_right_col colspan=\"2\">
    
    
                    <form name=\"log_form\" >
    
                      <input type=\"hidden\" name=\"focuslog\">

                          <textarea readonly  onFocus=\"this.blur();\" wrap=\"off\" cols=\"80\" rows=\"20\" name=\"command_output_textarea\">";
    
                          //Read from phpcron_output file

                          if ($path_errors=isPathBad($log_result_file,true,true)) {
    
    
                           
    

                            while ( list($file_or_dir, $error_string) = each($path_errors)) {
    

                              while (list($each_error)  = each($error_string)) {

                                $error_messages.=$path_errors[$file_or_dir][$each_error];
                              }
                             }
                             

                           $error_messages.="Error: Unable to read log file ".formatPath($log_result_file)."<br>

                           This will occur if Phpcron has not been run as a Daemon or Virtual Daemon yet, since
                           the log is only created at that point.<br>";
                           
    

                              $log_output=explode("<br>","ERROR: CANNOT DISPLAY LOG FILE\r\nTo create, run Phpcron in Daemon mode or as a Virtual Daemon.\r\n                         
                              ");
                           } else {
                              $log_output=file($log_result_file);
                           }
    
                          $options_output.=implode("",$log_output)."
                        </textarea>
    
                    </form>
    
                </td>
    
    
            </tr>
    

             <!--*************************END PHPCRON LOG DISPLAY IN TEXT AREA*********************-->

             <!--*************************BEGIN SUBMIT BUTTONS ****************************-->
             <tr>
                    <td style=$cp_right_col colspan=\"2\">

                    <form action=\"$PHP_SELF#log_display\" method=\"post\" onSubmit=\"document.log_form.scrollIntoView(false);\">
                    <input type=\"submit\" value=\"Update Display\">
                    
                    </form>
                    
                    <form action=\"$PHP_SELF\" method=\"get\">
                    <input type=\"submit\" value=\"Download Log File\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

                    <input type=\"hidden\" name=\"download_log\" value=\"true\">
                    </form>
    
                    <form action=\"$PHP_SELF\" method=\"get\">
                    <input type=\"submit\" value=\"Email Log File To:\">

                    <input type=\"text\" name=\"log_email_address\" value=\"$admin_email_address\"> 

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

                    <input type=\"hidden\" name=\"phpcron_command\" value=\"Email_Log\">
                    </form>
                    
                    <form action=\"$PHP_SELF\" method=\"get\">

                    <input type=\"submit\" value=\"Permanently Clear Log File\">

                    <input type=\"hidden\" name=\"admin_subpage\" value=\"Control_Panel\">

                    <input type=\"hidden\" name=\"phpcron_command\" value=\"Delete_Log\">
                    </form>
    
                    </td>
    
              </tr>

              <!--*************************END SUBMIT BUTTONS ****************************-->
    
    
    
              <tr>
                <td align=\"center\" colspan=\"2\" style=$cp_row_title>
                       &nbsp;
                </td>
    
            </tr>
    
            </table>
    
           <!--**********End Control Panel Table**************-->
            ";
    
        } else {
          

            /* Syntax for user config file allows comments but is somewhat strict -stick to 
            assignments only! and no sinqle quoted strings */
            $output.="
            </table>
            <!--**********End Control Panel Table**************-->
            ";
            $error_messages.= "

            <br>Error: Syntax error in user configuration file ".formatPath($user_config_file).". User configuration file should only

        contain variable assignments and comments in proper php syntax - and must include php ending script characters (only &lt?php and ?&gt 

        are supported). No other statements or html should be included. Please edit manually and try again.
            ";
        }
    
    
      /* Echo to Page */
    
      echo menuBar()."<br>";
        if ($error_messages) {
           echoErrorMessages($error_messages);
        }
      echo $output.
      $options_output;
        if($end_output){
        echo "
        <span class=\"notes\">
           <hr>
            $end_output
          <hr>
        </span>
        "; 
        }
      echo "
      <br>
      ".menuBar();
    
    
    }

  ------------------------------------------------------------------------

A.42. phpcron_admin/editTabByForm

  ------------------------------------------------------------------------

A.42.1. NAME

 

 editTabByForm

  ------------------------------------------------------------------------

A.42.2. SYNOPSIS

 

 void editTabByForm (string $phpcrontab_filename) 

  ------------------------------------------------------------------------

A.42.3. FUNCTION

 

 Displays form which edits the phpcrontab.conf file. 

  ------------------------------------------------------------------------

A.42.4. INPUTS

 

 string $phpcrontab_filename - string containing filename of phpcrontab.conf

  ------------------------------------------------------------------------

A.42.5. RESULT

 

 Echoes the phpcrontab.conf edit page

  ------------------------------------------------------------------------

A.42.6. SOURCE

 

    function editTabByForm($phpcrontab_filename){
    global $PHP_SELF;
    global $new_tabfilename;
    global $edit_table_title;
    global $edit_table_title_no_border;
    global $edit_tab_by_form;
    global $tab_save_error;
    global $new_tab_contents;
    global $old_tabfilename;
    global $create_tab;
    global $secure;
    
    
    

    /*NOTE: Allow create file: if there is no phpcrontab file or no parameters then 
    substitute another array for $line and save new file. */
    
    if ($tab_save_error) {
      $new_tabfilename=""; //initialize
      $phpcrontab_filename=$old_tabfilename;

      /* Don't read from file - just use attempted saved contents if save failure */
      $phpcronconf_array=explode("\n",stripslashes($new_tab_contents));
    } elseif(!$path_errors=isPathBad($phpcrontab_filename,true,true)) {

     /* Read conf file into an array, with each line being an element in the array */
    
    $phpcronconf_array=file($phpcrontab_filename);
    } else {
    
    if (is_readable($phpcrontab_filename)) {
    $phpcronconf_array=file($phpcrontab_filename);
    }
    //If there are  path errors, report them
    
        while ( list($file_or_dir, $error_string) = each($path_errors)) {
    
          while (list($each_message)  = each($error_string)) {
            $error_messages.=$path_errors[$file_or_dir][$each_message];
    
          }
        }
    

        $error_messages="<h3>Cannot Edit $phpcrontab_filename because of file errors:</h3>".$error_messages;
       
    }
    
    
    
    
    

        //Tests for existence of phpcrontab file - if does not exist, creates one
    
       if(!file_exists($phpcrontab_filename) or $create_tab) {
    
        if (!$create_tab) {

          $error_messages.="Creating new phpcrontab file - No existing file found for $phpcrontab_filename<br>";
        } else {
          $error_messages.="Creating new phpcrontab file<br>";
        }
        $create_tab=true;
        $create_tab_contents=
    "# comments: lines must begin with a #
    #  Phpcrontab.conf
    #The phpcontab.conf file contains a schedule of scripts/programs to
    # run in the traditional crontab format:

    # minute (0-59) hour (0-23) day of month (1-31) month(1-12) day of week(0-6)  command
    # Wild Cards are allowed. Each parameter is separated by one space.
    # Example:
    #
    # 59 3 * * 5  php sample_script.php   # every Friday at 3:59 a.m.
    #Ranges and multiple values will also work:

    # 0 0 1-15 * *   perl sample_script.pl   #executes on 1st through 15th of month

    # 0 0 1-3,15 * *   perl sample_script.pl   # executes on 1st-3rd and 15th of month
    #
    # MINUTES HOUR MONTHDAY MONTH WEEKDAYNUM
    ";
    
        $phpcronconf_array=explode("\n",$create_tab_contents);
    
        
       }
    
    $crontab_stripped=formatPath($phpcrontab_filename); 
    
    
    $output.="
        <!--**********Begin JavaScript*******************-->
        <SCRIPT LANGUAGE=\"JavaScript\" type=\"text/javascript\">
         <!--  
    
               function isNumberBetween(string,low,high) {
                for (i = 0; i < string.length; i++)
                {   
                    // Check that each character is number.
                    var c = string.charAt(i);
    
                    if (!((c >= \"0\") && (c <= \"9\"))) return false;
                }
    

               var number = parseInt (string); //converts string to integer 
                return ((number >= low) && (number <= high));
    
               }
    
            function trim(str)
            {
            var i = 0,j = str.length - 1;
    
                    while(str.charAt(i) == ' ') i++;
                    while(str.charAt(j) == ' ') j--;
            j++;
    
            return str.substring(i,j);
    
            }
    
    
    
    

            function validateField (field_string, textvalue, individual_parameter, theField, max_low, max_high) {
                   var warning_message=\"\";
    

                   if(!textvalue.match(/^(([0-9]{1,2}|[0-9]{1,2}-[0-9]{1,2}),?)+$/))

                     return warn(theField, textvalue + \" in the \" + field_string + \"  field is in an incorrect format.\");
    
    
    
                  for (i_array in individual_parameter)
                  {
    

                 /*warning_message=warning_message+\"i_array: \" + i_array + \"Being Evaluated:\" + individual_parameter[i_array] + \"\\r\\n\";
                 */
                   /* Check for Range */

                  if(individual_parameter[i_array].match(/^[0-9]*-[0-9]*,?$/)) {
    
                   var range=new Array();

                  range=individual_parameter[i_array].match(/[0-9]*-?/g) /* explode by hyphen*/
    

                      /*Just deletes , or - at end of string if it exists */
                     range[0]=range[0].replace(/[,-]/g,\"\");       
                     range[1]=range[1].replace(/[,-]/g,\"\");

                    /*warning_message=warning_message+ \"Low Value: \" + range[0] + \" High Value is: \" + range[1] + \"\\r\\n \";;
                    */
    
                    /*Make Sure High > Low */
    
                    if (parseInt(range[0])>=parseInt(range[1])) {
    

                    warning_message=warning_message + \"Low value of range \" + individual_parameter[i_array] + \" in \" + field_string + \" field is greater than or equal to high value.\\r\\n\";
    
    
                    }
                    for (i_range in range)
                    {
    

                      /*check each range to see if between correct values */

                       if (isNumberBetween(range[i_range],max_low,max_high)!=true)
                      {
                      if(range[i_range]==\"\") {
    
                      continue; //continue inner loop
    
                      }

                      warning_message=warning_message + range[i_range] + \" is in the \" + field_string + \" field which requires a number between \" + max_low + \" and \" + max_high +\".\\r\\n\";
    
                      }
    
    
                    }                     
    
    
                  continue; //continue outer loop
                  }

                    /*warning_message=warning_message+ \"Second Being Evaluated:\" + individual_parameter[i_array] + \"\\r\\n\";
                    */
                    /*Just deletes , or - at end of string if it exists */

                    individual_parameter[i_array]=individual_parameter[i_array].replace(/[,-]/g,\"\"); 
    
    

                       if (isNumberBetween(individual_parameter[i_array],max_low,max_high)!=true)
                      {
                      if(individual_parameter[i_array]==\"\") return true;

                      warning_message=warning_message + individual_parameter[i_array] + \" is in the \" + field_string + \" field which requires a number between \" + max_low + \" and \" + max_high +\".\\r\\n\";
                      }
                      i_array++;
                  }    
    
                  if(warning_message !=\"\") {

                  warning_message=\"Error(s):\\r\\n\" + warning_message;      
                  return warn(theField,warning_message);
                  } else {
                  return true;
                  }
    
    
            }
    
    
    
      function checkParameter(theField, parameter_type) {
      
        
          /*Textvalue is string hold all of values in field */
          textvalue=trim(theField.value);
          var i_array=0;
     
                
          if (textvalue == \"*\") return true;
          var individual_parameter=new Array();
          

          /*Fill Array Individual Parameter with Values Separated by , or hyphens*/

          individual_parameter=textvalue.match(/[0-9]+(-[0-9]+)?,?/g) /* took out hypen*/
      
              
          switch (parameter_type) {
          
                
          case 0:

          return validateField (\"Minutes\", textvalue, individual_parameter, theField, 0, 59);
    
          case 1:

          return validateField (\"Hour\", textvalue, individual_parameter, theField, 0, 23);
    
          case 2:

          return validateField (\"Day of Month\", textvalue, individual_parameter, theField, 0, 31);
    
          case 3:

          return validateField (\"Month\", textvalue, individual_parameter, theField, 1, 12);
    
          case 4:

          return validateField (\"Week Day\", textvalue, individual_parameter, theField, 0, 6);
          
          default:

          return warn(theField, \"Error in Code: Parameter Type is Invalid - Can't validate entry\");
          
           }
    
    
        }   
    
        
    
        function warn (theField, s){   
    
            alert(s);
    
            return false;
        }
    
    
        function NoEmpty(theField, s) {
        if(theField.value==\"\")
            alert(\"The \" + s + \" field requires an entry\");
        }
    
        -->  
    
        </SCRIPT>
        <!--**********End *******************-->
        
          

        <form action=\"$PHP_SELF?admin_subpage=Save_Edtab\" STYLE=\"margin-bottom: 0\" method=\"post\">
          

        <!--*************** Begin Schedule Programs Table (edit phpcrontab info ) *********-->

        <table align=\"center\" width=\"600px\" style=$edit_tab_by_form border=\"0\" cellspacing=\"0\" cellpadding=\"2\" summary=\"PHPCRONTAB Edit Form\">
    
         <tr >
          <td colspan=\"7\" align=\"center\" style=$edit_table_title>
          
            <h2>Schedule Programs</h2>";
    
    if ($create_tab) {
      $output.= "
      <h4>New PHPCRONTAB File</h4>";
    } else {
         $output.=
         "<h4>(edit ".chunk_split($crontab_stripped, 20, " ").")</h4>";
    }
    
    $output.="
           </td>
          </tr>
          ";
    
              $line_number=0;
            

             /* Loop through the array containing the lines of the phpcrontab.conf file */
             while ($line=$phpcronconf_array[$line_number]) {   
     
    
                     $line=trim($line); //trim extra spaces

                     /* Get lines which contain mixed parameters and comments */
                     preg_match("/#.*$/",$line, $side_line_comments);
                     /* Gets rid of # as first character of each line - 

                     add this back later when save file. User does not have to enter */

                        $side_line_comments[0]=preg_replace("/^#/m", "", trim($side_line_comments[0]));  
    
                     preg_match("/^#.*$/",$line, $full_line_comments); 
                    

                     /* Get rid of # as first character of each line - add this back later when save file. 

                       User does not have to enter. Also move lines over preserve vertical whitespace. */

                     $full_line_comments[0]=trim(preg_replace("/^#(.)/m", "\\1", trim($full_line_comments[0])));
                       //  preserve vertial whitespace

                       $full_line_comments[0]=preg_replace("/^#/m", " ", $full_line_comments[0]);
      
      
                       if($full_line_comments[0]) {
                      $top_line_comments.=$full_line_comments[0]."\r\n";
                      $number_of_top_comments++;
                    }
      
                  

                       if($param_headings_printed  and $full_line_comments[0]) {
                      $bottom_line_comments.=$full_line_comments[0]."\r\n";
                      $number_of_bottom_comments++;
                    }
                     /* Delete commented out sections and lines */
                     $line=preg_replace("/#.*$/","",$line); 
    
                     /* If line is a blank line then ignore line, otherwise
                       process commands */
    
                           if(!preg_match ("/^\s*$/", $line)) {
    

                      /*Print out Top Comments into a Text Area if haven't printed*/
    
                       if (!$param_headings_printed) {              
    

                         $output.=tabTopComments($top_line_comments, $number_of_top_comments);  

                        $param_headings_printed=true; //print headings only once
                
                      }
    
                          /* Parse line into a 6 element array (0-5), 

                            5 time parameters (minute, hour, day of month, month, day of week)
                            + command string */
                                $line = explode(" ", $line,6);
              

                                $command_text=array_pop($line);  // pop off the command text 

                          $command_text=trim ($command_text); //trim extra spaces
            

                            /* Cycle through first five parameters horizontally and put in 
                          text boxes */
    
                                $parameter_no=0;       
                                      
                          while ($parameter_no<5){
                  
                          $box_size=4;
                        
    
                          $output.= "
              
              <td align=\"center\" >        

                <input class=\"color\" name=\"ct_param[$line_number][$parameter_no]\" type=\"text\"  size=\"$box_size\" value=\"$line[$parameter_no]\" onChange=\"checkParameter(this, $parameter_no)\" >
              </td>";
                        
                                                
                          $parameter_no++;
                          }    
          
                          /* Add Commands and Side Line Comment Boxes */
    
                          $output.="
                  <td align=\"center\">

                    <input class=\"color\" type=\"text\" name=\"commands[$line_number]\" value=\"$command_text\"  onChange=\"NoEmpty(this, 'Commands')\">
                  </td>
                  <td align=\"center\">

                     <input class=\"color\" type=\"text\" name=\"side_line_comments[$line_number]\" value=\"$side_line_comments[0]\"> 
                  </td>
                  </tr>";
                  
            
                    } // end of check for blank line
                        $line_number++;
            
          } //end of parse loop  
    
           if (!$param_headings_printed) {
    

             /* If no commands in file, print out Top Comments into a Text Area as would not have
              previously printed */
             

             $output.=tabTopComments($top_line_comments, $number_of_top_comments);  
            $param_headings_printed=true; //print headings only once
          }
    

          /* Add 5 additional lines for new commands. Can do 5 at a time. */
    

              $max_lines=$line_number+5; //defines line number of last additional command input
              $output.="    
              <tr>

                  <td align=\"center\" style=$edit_table_title colspan=\"7\">
                    Add Commands (up to 5 at a time):
                  </td>
              </tr>
             <tr>
             ";
          
    
           while($line_number<$max_lines) { 
    
                 $parameter_no=0;       
      
              while ($parameter_no<5){
    
              $box_size=4;
          
    
              $output.= "
    <td align=\"center\" >        

    <input class=\"color\" name=\"ct_param[$line_number][$parameter_no]\" type=\"text\"  size=\"$box_size\" value=\"$line[$parameter_no]\" onChange=\"checkParameter(this, $parameter_no)\" >
    </td>
    ";
            
                                    
              $parameter_no++;
              }    
    
             $output.="         
               <td align=\"center\">

                 <input class=\"color\" type=\"text\" name=\"commands[$line_number]\" onChange=\"NoEmpty(this, 'Commands')\"> 
               </td>
               <td align=\"center\">

                 <input class=\"color\" type=\"text\" name=\"side_line_comments[$line_number]\">
               </td>
             </tr>
            <tr>
             ";
    
              $line_number++; 
          }
            
          /* Bottom Comments */
          $output.="

            <td align=\"center\" colspan=\"7\" style=$edit_table_title>Bottom Comments:</td></tr>
            <tr>
            <td colspan=\"7\" align=\"center\">

                <textarea name=\"bottom_line_comments\" cols=\"80\" rows=\"$number_of_bottom_comments\">$bottom_line_comments
              </textarea>
              </td>
          </tr>

          <!--*************** End Schedule Programs Section of Table (edit phpcrontab info ) *********-->   
          
      <tr>
        <td style=$edit_table_title_no_border colspan=7>
      
      <!--******* FORM SUBMITS*********-->
       ";
       if ($create_tab) {
       if (!$secure) {
       $output.="
         File: <em>New PHPCRONTAB File </em><br> 
         <input type=\"submit\" value=\"Save As:\">
    
          <input class=\"color\" type=\"text\" name=\"new_tabfilename\">" ;
        }
        $output.="
          <br>
          Check to Save Over Existing File:

           <input type=\"checkbox\" name=\"overwrite\" value=\"true\" class=\"title\">

            <input type=\"hidden\"  name=\"max_line_number\" value=\"$line_number\"> 
      

          <input type=\"hidden\" name=\"current_tabfilename\" value=\"$phpcrontab_filename\">
          
          </form>
        </td>
        </tr>
      <tr>
      <td style=$edit_table_title_no_border  colspan=7>
          ";
    
       } else {
       $output.="
           <HR>
          <input type=\"submit\" value=\"Save\">";
      if (!$secure) {
      $output.=  "
          <input type=\"submit\" value=\"Save As:\">
          <input class=\"color\" type=\"text\" name=\"new_tabfilename\">";
      }
      $output.="
          <br> 
          Check to Save Over Existing File:

          <input type=\"checkbox\" name=\"overwrite\" value=\"true\" class=\"title\">  

            <input type=\"hidden\" value=\"$line_number\" name=\"max_line_number\"> 

          <input type=\"hidden\" name=\"current_tabfilename\" value=\"$phpcrontab_filename\">
      
          
          </form>
        </td>
        </tr>
      <tr>
      <td border=0  style=$edit_table_title_no_border colspan=7>
          ";
    

          /* This allows another file to be opened - commenting this out because I changed my mind.

          Think its better for a crontab file to be opened by changing user configuration file. 

          But if you want to use this feature it is implemented, just uncomment.
             <form action=\"$PHP_SELF\" method=\"get\">
            <input type=\"submit\" value=\"Open:\">
          <input class=\"color\" type=\"text\" name=\"new_tabfilename\"> 

          <input type=\"hidden\" value=\"Edit_Tab_By_Form\" name=\"admin_subpage\">
          </form>
          */
    
      $output.="
          <form action=\"$PHP_SELF\" method=\"get\">
            <input type=\"submit\" value=\"Create New PHPCRONTAB File\">

          <input type=\"hidden\" value=\"Edit_Tab_By_Form\" name=\"admin_subpage\">
          
          <input type=\"hidden\" value=\"true\" name=\"create_tab\">
         </form> 
        </td>
        </tr>
      <tr>
      <td border=0 style=$edit_table_title_no_border  colspan=7> 
          ";
      } 
    
    $output.="
          <HR>
          File: <em>$crontab_stripped</em>
          </td>
          </tr>
      </table>
      <br>
       <!--*******END FORM SUBMITS *********-->";
    
      
                  if ($new_tabfilename) {
    
                if($path_errors=isPathBad($new_tabfilename, true)) {
    

                     while ( list($file_or_dir, $error_messages) = each($path_errors)) {
    

                      while (list($each_message)  = each($error_messages)) {

                        $error_messages.=$path_errors[$file_or_dir][$each_message]; 
                      }
                  }
    
                 }
    
    
                else {
                  $phpcrontab_filename=$new_tabfilename;
                  }
                }
    
      
      if($error_messages) {echoErrorMessages($error_messages);};
      echo $output;   
    
    
    
    } //end of function    

  ------------------------------------------------------------------------

A.43. phpcron_admin/fullEditBox

  ------------------------------------------------------------------------

A.43.1. NAME

 

 fullEditBox

  ------------------------------------------------------------------------

A.43.2. SYNOPSIS

 

 void fullEditBox (string $file_name, string $box_title) 

  ------------------------------------------------------------------------

A.43.3. FUNCTION

 

 Allows you to edit,save,and save the text file $file_name in a text box

  ------------------------------------------------------------------------

A.43.4. INPUTS

 

 string $filename - string containing filename of phpcrontab.conf
 string $box_title - string containing title of the edit box

  ------------------------------------------------------------------------

A.43.5. RESULT

 

 Echoes a textbox containing the contents of $filename with controls to 
 save, etc.

  ------------------------------------------------------------------------

A.43.6. SOURCE

 

    function fullEditBox($file_name, $box_title){
         global $admin_subpage;
         global $PHP_SELF;
         global $modified_contents;
         global $mc_rows;
         global $fe_save_error;
         global $full_edit_title;
         global $secure;
    
    
    
        if($path_errors=isPathbad($file_name, true, true)) {
    
          while ( list($file_or_dir, $error_string) = each($path_errors)) {
    
    
    
          while (list($each_message)  = each($error_string)) {
            $error_messages.=$path_errors[$file_or_dir][$each_message];  
        }
    
        }
    

        $error_messages="<h3>Cannot Edit $file_name because of file errors:<br></h3>".$error_messages;
        //if path errors, echo message and retur
        
        if (!is_readable($file_name)){
        echoErrorMessages($error_messages);
        echo $output;
        return;
        }
    
       }
        //Empty file into array
         $file_array=file($file_name);
    

        if ($fe_save_error) {   //if previously bad save, display modified contents that weren't saved
          $file_string=$modified_contents;
        } else {
    
          //Implode file_array to put string in text area element
           $file_string=addslashes(trim(implode("",$file_array)));
    
            //Set number of rows
           if ($file_array) {
               $total_lines=count($file_array);
            }
           $mc_rows=$total_lines+10;
    
        }
        //Build output
    
         $output="
        <!--*********** Begin Full Edit Box For $file_name************-->
        <br>

        <table border=\"1\" cellpadding=\"2\" width=\"600px\" cellspacing=\"0\" align=\"center\">
        <tr>
          <td align=center style=$full_edit_title colspan=7 >
           <h3>
      
              $box_title
              <br><br>
               (edit ".chunk_split(formatPath($file_name), 20, " ").")
              <br>
        
          </h3>
          </td>
        </tr>
        <tr>
          <td style=$full_edit_title>
    
             <form action=\"$PHP_SELF\" method=\"post\">
                <div align=\"center\">

                 <textarea name=\"modified_contents\"  wrap=\"off\" cols=\"80\" rows=\"$mc_rows\" 
                 class=\"fulledit\">".stripslashes($file_string)."
                 </textarea>
              </div>
               
               <HR>
               <input type=\"submit\" value=\"Save\">";
    if (!$secure) {
    $output.= "<input type=\"submit\" value=\"Save As:\">

               <input type=\"text\" class=\"color\" name=\"new_filename\">";
    }
     $output.=" <br>
                Check to Save Over Existing File:

               <input type=\"checkbox\" name=\"overwrite\" value=\"true\" class=\"title\">
            

                 <input type=\"hidden\" class=\"color\" name=\"current_filename\" value=\"$file_name\">

               <input type=\"hidden\" name=\"admin_subpage\" value=\"$admin_subpage\">
               <input type=\"hidden\" name=\"mc_rows\" value=\"$mc_rows\">
                   </form>
    
            
          <form action=\"$PHP_SELF\" method=\"post\">
            <input type=\"submit\" value=\"Reload Current File\">

             <input type=\"hidden\" name=\"admin_subpage\" value=\"$admin_subpage\">
    
          </form>
          <HR>
          Current File: ".formatPath($file_name)."
           </td>
          </tr>
        </table>
         <br>
         <!--*********** End Full Edit Box For $file_name*************-->
         ";
         if($error_messages) {
            echoErrorMessages($error_messages);
         }
         echo $output;
    
    }    
    

  ------------------------------------------------------------------------

A.44. phpcron_admin/getAssignmentInfo

  ------------------------------------------------------------------------

A.44.1. NAME

 

 getAssignmentInfo

  ------------------------------------------------------------------------

A.44.2. SYNOPSIS

 

 array getAssignmentInfo (array $uc_contents_array) 

  ------------------------------------------------------------------------

A.44.3. FUNCTION

 

 Used in parsing phpcron_userconfig.php. Determines the variable,
 value and type of a quoted variable assignment,

  ------------------------------------------------------------------------

A.44.4. INPUTS

 

 array $uc_contents_array[$horiz_pos]["executable"]
 

 A 2 dimensional array which contains the variable assignment strings derived 
 from  the phpcron_userconfig.php

  ------------------------------------------------------------------------

A.44.5. RESULT

 

 Returns false if a string in the array is not a variable assignment or, if
 successful, a three dimensional array containing variable name, value, and
 type for  each assignment in the $uc_contents_array:
 $return_value[$horiz_pos][$i]["variable"], 
 $return_value[$horiz_pos],[$i]["type"],  
 $return_value[$horiz_pos],[$i]["type"]
 This information is assigned to $assignment_info in cpPhpcron. 

  ------------------------------------------------------------------------

A.44.6. SOURCE

 

    function getAssignmentInfo ($uc_contents_array){ 

    /*Returns variable, value and type of quoted assignment (i.e., when $assignment is a 
    variable assignment like "a=3;" */
    
      global $user_config_file;
      global $uc_contents_length;
      include("$user_config_file");
    
      $horiz_pos=0;
    
      
      while($horiz_pos<$uc_contents_length) {
    
      if($uc_contents_array[$horiz_pos]["executable"]) {

      $executable_string.=  stripPhp($uc_contents_array[$horiz_pos]["executable"]);
      }
      $horiz_pos++;
      }

      /* Join Executable Strings and Test for syntax errors (if there are anything but 
      assignments, testedby comparing number of = with number of ; */
    

      if(preg_match_all("/;/", $executable_string, $semi_matches) <> preg_match_all("/=/",$executable_string,$equal_matches)) {
    

      return false; //syntax error in string - nunmber of assignments do not equal number of statements;
      }
    

      /* Cycle through array containing executable strings, explode and create 3 arrays containing
      variable, value and type */
    
      $horiz_pos=0;
      while($horiz_pos<$uc_contents_length) {
        //if this element is empty then skip the loop 
        if(!$uc_contents_array[$horiz_pos]["executable"]) { 
        $horiz_pos++;
        continue;
        } //end of if
    
        //strip html tags

        $uc_contents_array[$horiz_pos]["executable"]=trim(strip_tags($uc_contents_array[$horiz_pos]["executable"]));
      

        /* Turn uc_contents_array element into separate assignment strings */
    
         //break assignment_string into an array of separate assignments

        if(!$assignment_array[$horiz_pos]=explode(";",$uc_contents_array[$horiz_pos]["executable"])) {    
      
          return false; // error if no semi-colon in string
        }

              /* Run through assignment array and break into variable, values, and type */
              $i=0;
               while($assignment_array[$horiz_pos][$i]) {
              
                //assign variable to 0 and $value to 1; return if  

                if(!$temp=explode("=",$assignment_array[$horiz_pos][$i])) {  
      

                  return false; //returns false if this string does not contain an assignment
                  
                }
      
              $return_value[$horiz_pos][$i]["variable"]=$temp[0];
              $return_value[$horiz_pos][$i]["value"]=$temp[1];
          
               //maintain quotes for type testing

              $test_string=trim(stripslashes($return_value[$horiz_pos][$i]["value"])); 
           //strip slashes, trim, and get rid of quotes

              $value=trim(preg_replace("/\"/","",stripslashes($return_value[$horiz_pos][$i]["value"]))); 
              /*Derive Types*/
              if(preg_match("/^[0-9]*$/", $test_string)) {
                   $return_value[$horiz_pos][$i]["type"]="integer";

              } elseif ($return_value[$horiz_pos][$i]["value"]=="true" or $value =="false") {
                  $return_value[$horiz_pos][$i]["type"]="boolean";
              }elseif (preg_match("/^\".*\"$/", $test_string)){
                    $return_value[$horiz_pos][$i]["type"]="string";
              }  else {

                  echoErrorMessages("Error: A type could not be determined for variable 

                  $return_value[$horiz_pos][$i][$variable] - Check Syntax in User Configuration File $user_config_file. Only variable 

                  assignments of type String (surrounded by double quotes only), Integers, and Booleans are 
                  supported in that file.");
              
                  return false;
                }
    
              $i++;
            
              } //end of inside while
      
        $horiz_pos++;
    
      } //end of outside while
    
      /*Returns 3 array string containing variable name, value, 
        and  type for each assignment statement */
      
      return $return_value; 
    }    

  ------------------------------------------------------------------------

A.45. phpcron_admin/getComments

  ------------------------------------------------------------------------

A.45.1. NAME

 

 getComments 
 

  ------------------------------------------------------------------------

A.45.2. SYNOPSIS

 

 array getComments (string $big_string, string $left_char, 
                    string $right_char, string $current_pos) 
 

  ------------------------------------------------------------------------

A.45.3. FUNCTION

 

 Starting with the $current_pos position in $big_string, extracts from
 $big_string,  a php comment that begins with $left_char and ends with
 $right_char or the beginning   of a php block. Used when parsing the
 phpcron_userconfig.php

  ------------------------------------------------------------------------

A.45.4. INPUTS

 

 $big_string - string containing contents of phpcron_userconfig.php
 $left_char  - the beginning character of the comment
 $right_char - the ending character of the comment

  $current_pos - the current position of the parser in $big_string, getComments
                will search from this position forward

  ------------------------------------------------------------------------

A.45.5. RESULT

 

 Returns an array containing as the first element, the comment string, and the

 second  element the position after the comment in the $big_string.   contents
 are valid.

  ------------------------------------------------------------------------

A.45.6. SOURCE

 

    function getComments($bigstring, $left_char, $right_char, $current_pos) {
    

    //gets substring which is delimited by left_char and right_char, starting from $current_pos
    
    global $uc_contents_length;

    $end_of_string= substr($bigstring, $current_pos); //get rest of string from current position to end
    
      if(strstr($end_of_string, $right_char)) {
        if ($right_char=="\n") { //if this is a single line comment
            //position of ending comment not including ending character 
          $last_pos=strpos($bigstring, $right_char, $current_pos);
        } else {
          //position of ending comment including ending character

            $last_pos=strpos($bigstring, $right_char, $current_pos)+strlen($right_char); 
        }

        $substring= substr($bigstring, $current_pos, $last_pos-$current_pos); //get substring to end
      }  elseif (strstr($end_of_string, "?>")) {
         // position of end of php block - but don't include end
        $last_pos=strpos($bigstring, "?>", $current_pos)-1; 
        //get to end of php block

        $substring= substr($bigstring, $current_pos, $last_pos-$current_pos); 
      } else {  //otherwise, return end of string
        $last_pos=$uc_contents_length;
        $substring=$end_of_string;
      }
      $current_pos=$last_pos;
      $current_pos=$last_pos; //update current position

      $return_value = array ($substring, $current_pos);//return substring and current position
    
      return $return_value;
    
    }

  ------------------------------------------------------------------------

A.46. phpcron_admin/getFormElement

  ------------------------------------------------------------------------

A.46.1. NAME

 

 getFormElement 
 

  ------------------------------------------------------------------------

A.46.2. SYNOPSIS

 

 string getFormElement (string $variable, string $value, string $type,
                   int horiz_pos, int $variable_index) 
 

  ------------------------------------------------------------------------

A.46.3. FUNCTION

 

 Constructs a string containing HTML comprising an appropriate form element
 to pass a value appropriate for $variable. For instance, if the
 variable is a boolean variable, a true/false radio button will
 be constructed, if a string, a text box. Used to construct the
 control panel.
 

  ------------------------------------------------------------------------

A.46.4. INPUTS

 

 $variable - the string containing the name of the variable being analyzed 
             (extracted    from the phpuserconfig.php)
 $value    - a string containing the name of the value

 $type     -  a string conaining the name of the variable type (e.g., boolean,
              string, etc)   
 $horiz_pos  - the horizontal position where the parser is at in
                parsing the contents of phpuserconfig.php       

 $variable_index - a number used as the second index of the three dimensional 
                array which   holds the assignment info See cpPhpcron
 

  ------------------------------------------------------------------------

A.46.5. RESULT

 

 Returns a string containing an appropriate HTML form element for the 

 assignment type.    For instance, if the variable is a boolean variable, a 

 true/false radio button will   be constructed, if a string, a text box. Used 
  to construct the   control panel.
 

  ------------------------------------------------------------------------

A.46.6. NOTES

 

 See cpPhpcron

  ------------------------------------------------------------------------

A.46.7. SOURCE

 

    function getFormElement($variable, $value, $type, $horiz_pos, $variable_index) {
    

       $value=trim(preg_replace("/\"/","",stripslashes($value))); //strip slashes, trim, and get rid of quotes    
    
      $box_size=strlen($value);
      if($box_size > 40) {
       $box_size=40;     //size of text box
      }
    
      switch ($type) {
      case "integer":
        

        return "<input type=\"text\" class=\"color\" name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"$value\" size=\"$box_size\" onChange=\"isNumber(this)\">";
        break;
    
      case "boolean":
    
    
        if($value=="true") {  
        return "

            <input  type=\"radio\" checked name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"true\">On

            <input type=\"radio\" name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"false\">Off";
        } else {
        return "

            <input  type=\"radio\"  name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"true\">On

            <input type=\"radio\" checked name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"false\">Off";
        }
    
        break;
    
      case "string":
    
        return "

              <input type=\"text\" class=\"color\" name=\"assignment_info[$horiz_pos][$variable_index][value]\" value=\"$value\" size=\"$box_size\">";
        break;
      default:

        echoErrorMessages("Error: No Form Found for This Variable $variable- Check Syntax in User Configuration File. Only String, Integers, and
        Booleans are supported.");
        return false;
    
      }
    
    
    }    
    

  ------------------------------------------------------------------------

A.47. phpcron_admin/$uc_contents_array

  ------------------------------------------------------------------------

A.47.1. NAME

 

 $uc_contents_array

  ------------------------------------------------------------------------

A.47.2. DESCRIPTION

 

 A 2 dimensional array constructed of the following:
 $uc_contents_array[$horiz_pos]["executable"] 
        - the non-comment portions of phpcron_userconfig.php    
 $uc_contents_array[$horiz_pos]["ml_comments"]
        - the multi-line comment portions of phpcron_userconfig.php
 $uc_contents_array[$horiz_pos]["sl_comments"] 
        - the single line comment portions of phpcron_userconfig.php

  ------------------------------------------------------------------------

A.47.3. NOTES

 

 See cpPhpcron, parseUserConfig, rebuildUserCfg

  ------------------------------------------------------------------------

A.48. phpcron_admin/$assignment_info

  ------------------------------------------------------------------------

A.48.1. NAME

 

 $assignment_info

  ------------------------------------------------------------------------

A.48.2. DESCRIPTION

 

 A three dimensional array containing variable name, value, and
 type for  each assignment in the $uc_contents_array:
 $assignment_info[$horiz_pos][$i]["variable"], 
 $assignment_info[$horiz_pos],[$i]["type"],  
 $assignment_info[$horiz_pos],[$i]["type"]
 cpPhpcron assigns gets this information from a call
 to getAssignmentInfo in cpPhpcron.

  ------------------------------------------------------------------------

A.48.3. NOTES

 

 See cpPhpcron, getAssignmentInfo

  ------------------------------------------------------------------------

A.49. phpcron_admin/parseUserConfig

  ------------------------------------------------------------------------

A.49.1. NAME

 

 parseUserConfig

  ------------------------------------------------------------------------

A.49.2. SYNOPSIS

 

 array parseUserConfig(string $user_config_file, string $left_mlc_ch, 
                     string $right_mlc_ch, string $sc_ch)

  ------------------------------------------------------------------------

A.49.3. FUNCTION

 

 Parses the user configuration file $user_config_file, extracting single 
 line comments,multi-line comments, and command portions of
 $user_config_file

  ------------------------------------------------------------------------

A.49.4. INPUTS

 

 $user_config_file - the filename of the phpcron_userconfig.php
 $left_mlc_ch - the characters which mark the beginning of a mult-line
               comment  
 $right_mlc_ch - the characters which mark the end of a mult-line
               comment               

 $sc_ch - the characters which mark the beginning of a single-line character

  ------------------------------------------------------------------------

A.49.5. RESULT

 

 Returns  an array containing as its first element $uc_contents, a string
 containing the  contents of $user_config_file file and, as its second

 element, $uc_contents_array, a 2 dimensional array which contains the contents
 of the phpcron_userconfig.php

  ------------------------------------------------------------------------

A.49.6. NOTES

 

        See $uc_contents_array, cpPhpcron

  ------------------------------------------------------------------------

A.49.7. SOURCE

 

    function parseUserConfig($user_config_file, $left_mlc_ch, $right_mlc_ch, $sc_ch) {

    /* parse the userconfig file named in $file to separate out mult-line comments surrounded

    by $mlc_left_char and $mlc_right_char and single line comments begun with slc_ch */
    
    global $uc_contents;
    global $uc_contents_length;
    $current_pos=0;
    $horiz_pos=0;
    
        while ($current_pos<$uc_contents_length){
    

           $current_char=substr($uc_contents,$current_pos,strlen($left_mlc_ch));
    

           //if character is a multi-line comment then find to end character of multi-line comment
            if ($current_char==$left_mlc_ch) {
    

            if($uc_contents_array[$horiz_pos]["executable"]) {$horiz_pos++;}

            list($uc_contents_array[$horiz_pos]["ml_comments"], $current_pos)=getComments($uc_contents, $left_mlc_ch,$right_mlc_ch, $current_pos);
    
            $horiz_pos++;
    
          }  elseif($current_char==$sc_ch){
             //increment position for executable

            if($uc_contents_array[$horiz_pos]["executable"]) {$horiz_pos++;}

            list($uc_contents_array[$horiz_pos]["sl_comments"], $current_pos)=getComments($uc_contents, $sc_ch,"\n", $current_pos);
    
            $horiz_pos++;
            
          } else {

            $uc_contents_array[$horiz_pos]["executable"]=stripPhp($uc_contents_array[$horiz_pos]["executable"].substr($current_char,0,1)); //after comments are stripped out, assign all else to this
            }
          $current_pos++;
        }
        $return_value=array ($uc_contents, $uc_contents_array);
        return $return_value;
     }    
    
    

  ------------------------------------------------------------------------

A.50. phpcron_admin/rebuildUserCfg

  ------------------------------------------------------------------------

A.50.1. NAME

 

 rebuildUserCfg

  ------------------------------------------------------------------------

A.50.2. SYNOPSIS

 

 string rebuildUserCfg(array $assignment_info, array $uc_contents_array)

  ------------------------------------------------------------------------

A.50.3. FUNCTION

 

 Rebuilds the new phpcron_userconfig.php to be saved given the information 
 submitted by the control panel form.

  ------------------------------------------------------------------------

A.50.4. INPUTS

 

 $assignment_info - a three dimensional array containing the data submitted 
 by the control panel form

 $uc_contents_array - a 2 dimensional array containing the current contents of the
                     phpcron_userconfig.php such that:
                     $uc_contents_array
 

  ------------------------------------------------------------------------

A.50.5. RESULT

 

 A string containing the new contents of the phpcron_userconfig.php after
 editing by the control panel form. This string is meant to be saved
 as the new phpcron_userconfig file.

  ------------------------------------------------------------------------

A.50.6. NOTES

 

 See cpPhpcron

  ------------------------------------------------------------------------

A.50.7. SOURCE

 

    function rebuildUserCfg($assignment_info, $uc_contents_array) { //Print out Contents of File in Order
      

      /* This function rebuilds the user_config_file using the new information from $assignment_info 
      submitted by the user. */
      global $uc_contents_length;
      $horiz_pos=0;
    
        while($horiz_pos<$uc_contents_length) {
    
        $i=0;
    
    
        while($assignment_info[$horiz_pos][$i]["variable"] ) {
    

          if ($assignment_info[$horiz_pos][$i]["type"]=="string") { //add quotes for a string

              $assignment_info[$horiz_pos][$i]["value"]="\"".$assignment_info[$horiz_pos][$i]["value"]."\"";
          }
    
          if($i==0) {

          /* After first time add additional elements (don't replace - otherwise won't get
          additional assignments on same line) */

            $uc_contents_array[$horiz_pos]["executable"]=$assignment_info[$horiz_pos][$i]["variable"].

                                        "=".$assignment_info[$horiz_pos][$i]["value"].";";
    
          }else {

            $uc_contents_array[$horiz_pos]["executable"].=$assignment_info[$horiz_pos][$i]["variable"].

                                        "=".$assignment_info[$horiz_pos][$i]["value"].";";
          }
          /* For Debugging:
          echo "Horiz Pos: $horiz_pos Index: $i<br>";

          echo "Assignment Info Variable:".$assignment_info[$horiz_pos][$i]["variable"]."<br>";

          echo "Contents:".$uc_contents_array[$horiz_pos]["executable"]."<br>";

          echo "SL Comments:".$uc_contents_array[$horiz_pos]["sl_comments"]."<br>";

          echo "ML Comments:".$uc_contents_array[$horiz_pos]["ml_comments"]."<br>";
          */
    
          $i++;
        }
    
        if($uc_contents_array[$horiz_pos+1]["sl_comments"]) {
          $plus1=$horiz_pos+1;
          /*For Debugging

          echo "Exec Contents $horiz_pos:".$uc_contents_array[$horiz_pos]["executable"]."<br>";

          echo "Exec Contents:".$plus1.$uc_contents_array[$horiz_pos+1]["executable"]."<br>";

          echo "sl comments again:".$plus1.$uc_contents_array[$horiz_pos+1]["sl_comments"];
          */
    

          /*only add tab if there are commands on same line (the executable element 
          holds a word character)*/

          if (preg_match("/\w/",$uc_contents_array[$horiz_pos]["executable"])){ 
          

          $uc_contents_array[$horiz_pos+1]["sl_comments"]="\t".$uc_contents_array[$horiz_pos+1]["sl_comments"]."\n";
          } else {    
    

          $uc_contents_array[$horiz_pos+1]["sl_comments"]=$uc_contents_array[$horiz_pos+1]["sl_comments"]."\n";
          
          }
        }
      
        if($uc_contents_array[$horiz_pos]["ml_comments"]) {

          $uc_contents_array[$horiz_pos]["ml_comments"]=$uc_contents_array[$horiz_pos]["ml_comments"]."\n";
        }

        $new_file_contents.=$uc_contents_array[$horiz_pos]["sl_comments"].$uc_contents_array[$horiz_pos]["ml_comments"].$uc_contents_array[$horiz_pos]["executable"];
        $horiz_pos++;
      
        }

        $new_file_contents="\r\n<?php\r\n\r\n".trim(stripslashes($new_file_contents))."\r\n\r\n?>"; //add php tags
        return $new_file_contents;
      }    
    

  ------------------------------------------------------------------------

A.51. phpcron_admin/stripPhp

  ------------------------------------------------------------------------

A.51.1. NAME

 

 stripPhp

  ------------------------------------------------------------------------

A.51.2. SYNOPSIS

 

 string stripPhp(string $phpstring)

  ------------------------------------------------------------------------

A.51.3. FUNCTION

 

 Strips $phpstring of the <?php and the ?> tags

  ------------------------------------------------------------------------

A.51.4. INPUTS

 

 A string containing a php script.

  ------------------------------------------------------------------------

A.51.5. RESULT

 

 The contents of the php script without the beginning and  ending php
 tags.

  ------------------------------------------------------------------------

A.51.6. SOURCE

 

    function stripPhp($phpstring) {
       $phpstring=preg_replace("/(<\?php)|(\?>)/","",$phpstring); 
      return $phpstring;
    }    

  ------------------------------------------------------------------------

A.52. phpcron_admin/tabTopComments

  ------------------------------------------------------------------------

A.52.1. NAME

 

 tabTopComments

  ------------------------------------------------------------------------

A.52.2. SYNOPSIS

 

 string tabTopComments(string $top_line_comments, int $number_of_top_comments)

  ------------------------------------------------------------------------

A.52.3. FUNCTION

 

 Creates a row of a table containing a textarea containing the top comments of
 the phpcrontab.conf. Comprises a part of the form which edits the
 phpcrontab.conf file.

  ------------------------------------------------------------------------

A.52.4. INPUTS

 

 $top_line_comments - a string created in editTabByForm containing  all of the
                      comments at the top of the phpcrontab.conf file 

 $number_of_top_comments - number of lines of top comments in phpcrontab.conf

  ------------------------------------------------------------------------

A.52.5. RESULT

 

 A string containing the HTML for producing the table row containing the 
 textarea holding the top comments of phpcrontab.conf 

  ------------------------------------------------------------------------

A.52.6. NOTES

 

 See editTabByForm

  ------------------------------------------------------------------------

A.52.7. SOURCE

 

    function tabTopComments($top_line_comments, $number_of_top_comments) {
    global $edit_table_title;
     return " <tr>
                 <td align=\"center\" colspan=\"7\">

                 <textarea name=\"top_line_comments\" cols=\"80\" wrap=\"off\" rows=\"$number_of_top_comments\">$top_line_comments                      
                 </textarea>
                </td>
              </tr>
               <tr align=\"center\" style=$edit_table_title>
           
                     <td style=$edit_table_title>
                          Min<br>(0-59)
                    </td>
                     <td style=$edit_table_title>
                          Hour<br>(0-23)
                    </td>
                     <td style=$edit_table_title>
                          Month<br>Day<br>(1-31)
                    </td>
                     <td style=$edit_table_title>
                          Month<br>(1-12)
                    </td>
                     <td style=$edit_table_title>
                          Week<br>Day<br>(0-6)
                    </td>                                            
                    <td style=$edit_table_title>
                        Commands 
                    </td>
                    <td style=$edit_table_title>
                      Comments
                    </td>
                </tr>
                <tr>
                ";
    }    

Generated from phpcron_commonlib.php with ROBODoc v3.2.3 on Wed Oct 24
21:26:43 2001

  ------------------------------------------------------------------------

A.53. PHPCRON/phpcron_commonlib_readme

  ------------------------------------------------------------------------

A.53.1. NAME

 

 phpcron_commonlib.php

  ------------------------------------------------------------------------

A.53.2. DESCRIPTION

 

 This is a collection of functions used by both
 phpcron.php and phpcron_admin.php.

  ------------------------------------------------------------------------

A.53.3. AUTHOR

 

 David C. Druffner
 ddruff@gemini1consulting.com

  ------------------------------------------------------------------------

A.53.4. COPYRIGHT

 

 COPYRIGHT 2001 (C) David C. Druffner
 ddruff@gemini1consulting.com
 This script is released under a modified BSD License.
 See php phpcron.php -license and LICENSE.txt in download package 
 for full license details

  ------------------------------------------------------------------------

A.53.5. BUGS

 

 Bugs can be reported via the online manual:
 [40]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/

  ------------------------------------------------------------------------

A.53.6. NOTES

 

 This is a collection of functions used by both
 phpcron.php and phpcron_admin.php.

 The current manual for Phpcron and Phpcron Admin is located at 
 [41]http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
 The Home Page is:
 [42]http://phpcron.sourceforge.net/
 Download from the Source Forge Project Page:
 [43]http://www.sourceforge.net/projects/phpcron/
 In-Line Documentation:
 A slightly modified version of ROBODOC is used to

 generate documentation for   this code. I have modified the headers.c file in
 the Robodoc source code to  et  the variable header_markers to equal only

 /*ROBODOC* as the start of a  header  marker - this avoids confusion with other
 strings and comments in PHP  code.   Robodoc is available at
 [44]http://www.xs4all.nl/~rfsber/Robo/robodoc.html

  ------------------------------------------------------------------------

A.54. phpcron_commonlib/$license

  ------------------------------------------------------------------------

A.54.1. NAME

 

 $license

  ------------------------------------------------------------------------

A.54.2. DESCRIPTION

 

 Variable containing text of license 
/
license="
hpcron, Phpcron Admin, and all associated and packaged scripts carry the
ollowing license:
OPYRIGHT (C) 2001 David Druffner
druff@gemini1consulting.com
edistribution and use in source and binary forms, with or without
odification, are permitted provided that the following conditions are met: 

1.Redistributions of source code must retain the above copyright notice, this
ist of conditions and the following disclaimer.  
2.Redistributions in binary form must reproduce the above copyright notice,
his list of conditions and the following disclaimer in the documentation
nd/or other materials provided with the distribution. 
3.The name of the author may not be used to endorse or promote products
erived from this software without specific prior written permission.  
HIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
ARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
ERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
VENT SHALL THE AUTHOR, ANY DISTRIBUTOR, OR ANY DOWNLOAD HOSTING COMPANY BE
IABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
ONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
UBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
NTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
ONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
RISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
OSSIBILITY OF SUCH DAMAGE.   
;
ROBODOC_END*/

  ------------------------------------------------------------------------

A.55. phpcron_commonlib/$phpcron_file

  ------------------------------------------------------------------------

A.55.1. NAME

 

 $phpcron_file 

  ------------------------------------------------------------------------

A.55.2. DESCRIPTION

 

 Variable containing path to phpcron.php 

  ------------------------------------------------------------------------

A.56. phpcron_commonlib/$phpcron_psinfo_file

  ------------------------------------------------------------------------

A.56.1. NAME

 

 $phpcron_psinfo_file 

  ------------------------------------------------------------------------

A.56.2. DESCRIPTION

 

 Variable containing path and filename of file
 containing information for the process
 running the phpcron.php script.

  ------------------------------------------------------------------------

A.57. phpcron_commonlib/$phpcron_venabled_file

  ------------------------------------------------------------------------

A.57.1. NAME

 

 $phpcron_venabled_file 

  ------------------------------------------------------------------------

A.57.2. DESCRIPTION

 

 If this file exists, then phpcron.php in non-daemon mode will run the
 scheduled commands in phpcrontab.conf 

  ------------------------------------------------------------------------

A.58. phpcron_commonlib/$phpcron_off

  ------------------------------------------------------------------------

A.58.1. NAME

 

 $phpcron_psinfo_file - path and filename of file the existence of 
 which causes phpcron.php to shut down
OBODOC_END*/
 
phpcron_off=$phpcron_directory."phpcron_off"; 
*ROBODOC*d phpcron_commonlib/MS_WINDOWS
 

  ------------------------------------------------------------------------

A.58.2. NAME

 

 MS_WINDOWS - constant - true if OS is Windows, false if not

  ------------------------------------------------------------------------

A.58.3. FUNCTION

 

 Used to check if OS is Windows or Unix.

  ------------------------------------------------------------------------

A.59. phpcron_commonlib/$viewed_by_browser

  ------------------------------------------------------------------------

A.59.1. NAME

 

 $viewed_by_browser - true if script is read by browser, false if console

  ------------------------------------------------------------------------

A.59.2. FUNCTION

 

 True if script is read by browser, false if executed on the
 command line. Set automatically by script on each execution 
 by reading whether $SERVER_PROTOCOL or $HTTP_USER_AGENT is set.

  ------------------------------------------------------------------------

A.59.3. BUGS

 

 I'm sure this won't work in all cases, but was the best solution
 I could come up with. Some web servers might not give out these
 variables and the script would interpret that to mean that
 it was being executed on the command line. The main result of this
 in phpcron.php is that the HTML tags would be stripped from all output
 (probably leading to a blank screen)and a built-in safeguard
 against going into daemon mode would be disabled (but there
 are other safeguards that should still prevent this).

  ------------------------------------------------------------------------

A.59.4. NOTES

 

 If phpcron.php is executed in a browser in daemon mode than an httpd
 process would be spawned that would only be able to be killed by 
 root (or by a self-kill if it detects a phpcron_off file in
 existence). This is a BAD THING as it could lead to server overload.
 Thus the daemon mode is shut off if a browser is detected. In addition,
 phpcron.php has certain self-checks to kill itself if there
 is another phpcron.php process running in daemon mode. See
 the function isOtherPhpcrond.

  ------------------------------------------------------------------------

A.59.5. SOURCE

 

     if ($SERVER_PROTOCOL or $HTTP_USER_AGENT) {    
    
     $viewed_by_browser=true;
      $slow_debug_scroll=0; 
      } else {
        $viewed_by_browser=false;
      }    

  ------------------------------------------------------------------------

A.60. phpcron_commonlib/checkPhpVersion

  ------------------------------------------------------------------------

A.60.1. NAME

 

 checkPhpVersion - formats string to conform to HTML/XML standards

  ------------------------------------------------------------------------

A.60.2. SYNOPSIS

 

 boolean checkPhpVersion(string $required_version, string $warning_string, 
 boolean $quit) 

  ------------------------------------------------------------------------

A.60.3. FUNCTION

 

 Verifies that the PHP version running on the Web Server is at least
 equal to the version required by the script.

  ------------------------------------------------------------------------

A.60.4. INPUTS

 

 $a, $b, $c   -strings containing minimum PHP version needed by the Script,
                e.g., 3.0.0. would be 3,0,0
 $warning_string    -optional parameter to be output to the user if fails 
                      version check
 $quit  - optional parameter which if true will force the 
          cript to end 

  ------------------------------------------------------------------------

A.60.5. RESULT

 

 Returns true if version of PHP is at least the minimum, false otherwise

  ------------------------------------------------------------------------

A.60.6. SOURCE

 

    function checkPhpVersion ($version_required, $warning_string="/", $quit=false) {
    
    
    $version_installed=phpversion();
    /*Break Up $version_required string by decimal point*/
    $version_required=explode(".", $version_required);
    

    if (!ereg( "[[$version_required[0]-9]\.[$version_required[1]-9]\.[$version_required[2]-9].*", $version_installed )){
    
     if ($warning_string !="/") {
        sendOutput($warning_string);
      }
      if ($quit) {
      
      exit;
      }
    
      return false;
    exit;
    } else {
    
    return true;
    }
    
    
    
    }    

  ------------------------------------------------------------------------

A.61. phpcron_commonlib/sendOutput

  ------------------------------------------------------------------------

A.61.1. NAME

 

 sendOutput - handles output depending on environment and global variables

  ------------------------------------------------------------------------

A.61.2. SYNOPSIS

 

 void sendOutput(string $output, boolean $suppress_override)

  ------------------------------------------------------------------------

A.61.3. FUNCTION

 

 Handles all output for phpcron.php. If a command line suppression switch has

 been turned on,  then the output is not echoed, unless the $suppress_override
 parameter is set to true (default is false) - usually done for critical

 errors.  Also, if the $redirect_output flag is true, the output will not be
 echoed  to the screen, but to the $redirect_file.  If the output is being
 sent to the browser, the output is left alone,  but if is being printed to
 the console as the output from a command line  script, than all html is
 stripped.

  ------------------------------------------------------------------------

A.61.4. INPUTS

 

 $output   - string containing output being echoed

 $suppress_override - optional parameter, if set the echo will occur whether
 or not the global output suppression has been turned
 on (see $suppress_output)

  ------------------------------------------------------------------------

A.61.5. NOTES

 

 Relies on values in global variables $viewed_by_browser, $suppress_output, 
 $redirect_output, and $redirect_file

  ------------------------------------------------------------------------

A.61.6. SOURCE

 

    function sendOutput($output_message, $suppress_override=false) {
    
    global $suppress_output;
    
    global $viewed_by_browser;
    global $redirect_output;
    global $redirect_file;
    
          if(!$suppress_output or $suppress_override) {
    
    
              //display message
              if (!$viewed_by_browser) {
                $output_message=strip_tags($output_message);
              }
    
              if ($redirect_output) {
    
              $save_results=appendToFile($output_message, $redirect_file);
    
              if (!$save_results[0]) {
                  //echo error messages
                  echo "Error: Cannot Append to File $redirect_file.".

                                                     "Check filename and permissions.\r\n";
              }
    
              } else {
    
              echo $output_message;
    
              }
          }
    }    

  ------------------------------------------------------------------------

A.62. phpcron_commonlib/getProcessInfo()

  ------------------------------------------------------------------------

A.62.1. NAME

 

 getProcessInfo() - formats string to conform to HTML/XML standards

  ------------------------------------------------------------------------

A.62.2. SYNOPSIS

 

 $string getProcessInfo(void) 

  ------------------------------------------------------------------------

A.62.3. FUNCTION

 

 When called returns information for the process running the PHP script
 (Unix only). Relies on a ps ef system call.

  ------------------------------------------------------------------------

A.62.4. RESULT

 

 Returns a three element string array:
 $process_info["all"] - all the proces info returned by ps ef
 $process_info["id"] - gives the $pid of the process
 $process_info["owner"] - gives the owner of the process

  ------------------------------------------------------------------------

A.62.5. SOURCE

 

    function getProcessInfo () {
    //get process info of current process
      global $pid;
        //get owner of script process
        if (!MS_WINDOWS) { //show pid info if not in windows
        
          exec("ps hefp $pid u", $output, $return_value);
          $output=implode(" ", $output);
    
          // get owner of process and put in $matches[1];
    
    
          preg_match("/(^[A-z0-9A-Z]*\b).*$/",$output,$matches);
          $process_info["all"]=$matches[0];
          $process_info["owner"]=$matches[1];
          $process_info["id"]=$pid;
    
    
        return $process_info;
       }
       //return nothing if windows/dos
    }    

  ------------------------------------------------------------------------

A.63. phpcron_commonlibp/isPathbad

  ------------------------------------------------------------------------

A.63.1. NAME

 

 isPathbad

  ------------------------------------------------------------------------

A.63.2. SYNOPSIS

 

 boolean isPathbad(string $path_name, 
 [boolean $check_filename, [$file_existing=false)]);  

  ------------------------------------------------------------------------

A.63.3. FUNCTION

 

 Checks whether directory and/or filename exists and is readable/writeable 
 (filename checked only if $check_filename is true, the default is false).
 Can be used both for dos and unix paths.

  ------------------------------------------------------------------------

A.63.4. INPUTS

 

 $path_name - string containing path name.
 
 $check_filename -
 
 Optional boolean parameter. Default is false. If true,
 then  will do check on filename as well as directory and will return   an
 error message if no file name was include_onced in the path.       
 
 $file_existing         - 
 optional boolean parameter (requires $check_filname to be
 set) that tells whether or not the file is existing. 

  ------------------------------------------------------------------------

A.63.5. RESULT

 

 If there are errors in testing the path, it returns a double array 
 containing error messges in the format of $file_errors["dir"] and
 $file_errors["file"]. If there are no errors, it returns false.
 
 The double array can be extracted using the list command like this: 
 
 if($path_errors=isPathbad($path_name)){
 
 while ( list($file_or_dir, $error_messages) = each($path_errors)) {
 
 while (list($each_message)  = each($error_messages)) {
 echo $path_errors[$file_or_dir][$each_message]."<br>";  
 }
 }
 }
 

  ------------------------------------------------------------------------

A.63.6. EXAMPLE

 

 $path_errors=isPathBad("/test/test.txt", true);  
 if ($path_errors["directory"] or $path_errors["file"]["write"]) { 
 $output="Error:  Cannot write to test/text.txt. The following errors were
 encountered.:<br>\r\n";  
 while ( list($file_or_dir, $error_messages) = each($path_errors)) 
 {  
 while (list($each_message)  = each($error_messages)) 
 {
 $output.= $path_errors[$file_or_dir][$each_message]."<br>\r\n";
 }
 }
 echo $output;
 
 
 } 

  ------------------------------------------------------------------------

A.63.7. SOURCE

 

    function isPathbad($path_name, $check_filename=false, $file_existing=false) {                                                                                                                                                                                                           

                                                                                                                                                            
    
      $dir_name=dirname($path_name)."/";
      $base_file_name=basename($path_name);
      $basename_stripped=formatPath($base_file_name);
      $dir_stripped=formatPath($dir_name);
      $pathname_stripped=formatPath($path_name);
    
    
        //Check Directory
    
       if(!file_exists($dir_name)){

         $path_errors["directory"]["exist"]="Error: Directory $dir_stripped does not exist. Please Create.<br>";
       }
    
         elseif(!is_writeable($dir_name)){
    

          $path_errors["directory"]["write"]="Error: Directory $dir_stripped cannot be written to. Check permissions.<br>";
       }
       elseif(!is_readable($dir_name)){

         $path_errors["directory"]["read"]="Error: Directory $dir_stripped cannot be read from. Check permissions.<br>";
       }
    
    
       //Check File Name
    

       if ($check_filename and !$base_file_name) { //if file name is required but not suppplied, print error

           $path_errors["file"]["empty"]="Error: $pathname_stripped is an invalid path. No file name was supplied.<br>";
          }
    
       if ($check_filename and $base_file_name) {
    
          //check filename format
    

          if((MS_WINDOWS and !preg_match("/^[-\.a-zA-Z0-9\s_\^\$~!#&\}\{\(\)@'`]+?$/",$base_file_name))or (!MS_WINDOWS and !preg_match("/^.[^\*\?&`'\"\/\>\)\(\]\[\<(\)]+?$/",$base_file_name))) { //check for proper characters in names
    

                  $path_errors["file"]["name"] ="\tError: File $pathname_stripped  contains invalid characters in file name.\r\n<br>";
    
           }
    
          if ($file_existing) {
    
             if(!file_exists($path_name)){

                   $path_errors["file"]["exist"]="Error: File $pathname_stripped does not exist.<br>";
             } elseif(!is_file($path_name)){

                   $path_errors["file"]["regular"]="Error: Invalid filename. $basename_stripped is a directory.<br>";
    
             }   elseif(!is_writeable($path_name)){

                      $path_errors["file"]["write"]="Error: File $pathname_stripped cannot be written to. Check permissions on file.<br>";
             }   elseif(!is_readable($path_name)){

                   $path_errors["file"]["read"]="Error: File $pathname_stripped is not readable. Check permissions.<br>";
             }
    
        }
    
    
    
    
      }
        return $path_errors;
    
    }    

  ------------------------------------------------------------------------

A.64. phpcron_commonlib/formatPath

  ------------------------------------------------------------------------

A.64.1. NAME

 

 formatPath

  ------------------------------------------------------------------------

A.64.2. SYNOPSIS

 

 $string formatPath(string $path_name);  

  ------------------------------------------------------------------------

A.64.3. FUNCTION

 

 Takes a string containing a path name and makes it conform to the operating

 specific  path format for readability, e.g, for dos "c:/test/test.txt" ->  

 "c:\test\test.txt".    This is meant to be used as a filter before the string
 is   output to the screen so it becomes "human readable". This function 
 assumes that the   path name is in unix format to begin with, so if used

 under a unix OS the string   returned for "c/test/test.txt" would be the same

 as the input. In addition, this function also adds the current directory to
 any path that   lacks an absolutte directory, e.g,"test.txt" would become
 /home/httpd/html/test.txt   if the script was being executed in
 /home/httpd/html/. 

  ------------------------------------------------------------------------

A.64.4. PURPOSE

 

 Used as a cross-OS function to format the path name before it is echoed

 to the user. No matter what the Operating System, the path will be readable
 to the user when it is echoed to the screen.

  ------------------------------------------------------------------------

A.64.5. INPUTS

 

 $path_name - string containing path name. 

  ------------------------------------------------------------------------

A.64.6. RESULT

 

 Returns a string containing the $path_name in os appropriate format. 

  ------------------------------------------------------------------------

A.64.7. NOTES

 

 CURRENT_DIRECTORY is a constant which must be defined in the 
 calling script as follows:
 define ("CURRENT_DIRECTORY",realpath(dirname(__FILE__)));                

  ------------------------------------------------------------------------

A.64.8. SOURCE

 

                
    function formatPath($path_name) {
    

    //Note for this to work you must define CURRENT_DIRECTORY as follows in main script:
    //define ("CURRENT_DIRECTORY",realpath(dirname(__FILE__)));
                                                                     
    

    /* Give a Directory Name if using same directory of script and none is otherwise specified*/
    if (dirname($path_name)==".") {
      $path_name=CURRENT_DIRECTORY."/".basename($path_name);
    
    }
                                     
    
      if(MS_WINDOWS) {
      $path_name=stripslashes($path_name);
    

      $path_name=preg_replace("/\//","\\",$path_name);  //get rid of any forward slashes
      }
                                     
       return $path_name;
      
    }    
    

  ------------------------------------------------------------------------

A.65. phpcron_commonlib/is_email

  ------------------------------------------------------------------------

A.65.1. NAME

 

 is_email

  ------------------------------------------------------------------------

A.65.2. SYNOPSIS

 

 boolean is_email(string $email_address);  

  ------------------------------------------------------------------------

A.65.3. FUNCTION

 

 Validates an email address

  ------------------------------------------------------------------------

A.65.4. INPUTS

 

 $email_address                 - string containing an email address

  ------------------------------------------------------------------------

A.65.5. RESULT

 

 Returns a true if email is in correct format, false if not 

  ------------------------------------------------------------------------

A.65.6. BUGS

 

 None known, but since domain formats are constantly changing, there
 may be some obscure domains that this function will see as incorrect
 emails and not accept.           

  ------------------------------------------------------------------------

A.65.7. SOURCE

 

    function is_email($email_address) {     
    

        if(!preg_match("/[\w\-][^@]+\@[\w\-][^@]+\.[\w\-][^@]+/",$email_address)) {
    
              return false;
        }  else {
            return true;
        }
    }    

  ------------------------------------------------------------------------

A.66. phpcron_commonlib/appendToFile

  ------------------------------------------------------------------------

A.66.1. NAME

 

 appendToFile

  ------------------------------------------------------------------------

A.66.2. SYNOPSIS

 

 string array appendToFile(string $new_file_contents, string $file_name);

  ------------------------------------------------------------------------

A.66.3. FUNCTION

 

 Appends $new_file_contents to file named by $file_name, if $file_name 
 does not exist, it will be created.

  ------------------------------------------------------------------------

A.66.4. INPUTS

 

 $new_file_contents  -  string containing text to be added to file
 $file_name          -  path and filename of file to be appended to

  ------------------------------------------------------------------------

A.66.5. RESULT

 

 Returns a string array containing error messages; the first element of the

 array  contains a success message, if it was unsuccessful, the first element 

 is empty (false) and the remaining elements (1-last) contain error  messages.

  ------------------------------------------------------------------------

A.66.6. EXAMPLE

 

 Example 1 - Short form:
 
 $append_results=appendToFile($clear_message,$log_result_file);
 $append_results[0]=""; //does not echo success message, but you could
 if(trim($append_results)) {
 $error_messages.=implode(" ",$append_results);
 echo $error_messages;
 }
 
 Example 2 - Long form:
 
 $append_results=appendToFile($contents, $filename);
 if($append_results[0]) { //this would be successful save        
 //this collects the success message 
 $error_messages.=$append_results[0]; 
 } else { //append so collect error messages in elements 1 - last
 $index=1;
 while($append_results[$index]) {
 $error_messages.=$append_results[$index];
 $index++;
 }
 }
 echo $error_messages;  

  ------------------------------------------------------------------------

A.66.7. NOTES

 

 Relies on these other functions:
 /phpcron_commonlib/formatPath                                   
 /phpcron_commonlib/isPathbad 

  ------------------------------------------------------------------------

A.66.8. SOURCE

 

    function appendToFile($new_file_contents, $file_name)   {
    
    
    
      if(!trim($file_name)) {
    
          $save_results[1]="Error: No File Name Given";
          return $save_results;
      }
    
       $filename_stripped=formatPath($file_name);
    
    
           $path_errors=isPathbad($file_name, true, true);
          //check if directory is valid and file name is legal

          if (!$path_errors["directory"] and !$path_errors["file"]["name"]) {
    

           /* Open for reading and writing, place file pointer at end of file (append)
            , if does not exist attempt to create it */
    
              $fp = fopen( $file_name,"a+");
    
              if (!$fp) {

                   $open_error="Error: File $filename_stripped Cannot Be opened. Check Permissions.<br>\n";
                 } else {
                 fwrite($fp,$new_file_contents);
                 fclose ($fp);

              $save_results[0]="<strong>File $filename_stripped has been successfully saved.<strong><br>";
              }
    
           } else {
    
                   $i=1;

                  $save_results[1]="Error: Cannot save file $filename_stripped.<br>";

                     while ( list($file_or_dir, $error_messages) = each($path_errors)) {
    

                      while (list($each_message)  = each($error_messages)) {
    

                        $save_results[$i].= $path_errors[$file_or_dir][$each_message];
                        $i++;
                      }
                  }
    
    
    
    
        }
    
        if ($open_error) {
    
            $save_results[$i]=$open_error;
        }
    
        return $save_results;
     }     

  ------------------------------------------------------------------------

A.67. phpcron_commonlib/saveFile

  ------------------------------------------------------------------------

A.67.1. NAME

 

 saveFile

  ------------------------------------------------------------------------

A.67.2. SYNOPSIS

 

 string array saveFile(string $file_contents, string $file_name);

  ------------------------------------------------------------------------

A.67.3. FUNCTION

 

 Saves $file_contents to file named by $file_name. If $file_name already
 exists it will be overwritten, if not, it will be created.

  ------------------------------------------------------------------------

A.67.4. INPUTS

 

 $file_contents  -  string containing text to be saved
 $file_name      -  path and filename of file to be saved

  ------------------------------------------------------------------------

A.67.5. RESULT

 

 Returns a string array containing error messages; the first element of the
 array  contains a success message (or false if it failed). If it was
 unsuccessful, the remaining elements (1-last) contain error  messages. 

  ------------------------------------------------------------------------

A.67.6. EXAMPLE

 

 
 Example 1 - Short form:
 
 $save_results=saveFile($clear_message,$log_result_file);
 $save_results[0]=""; //does not echo success message, but you could
 if(trim($save_results)) {
 $error_messages.=implode(" ",$save_results);
 echo $error_messages;
 }
 
 Example 2 - Long form:
 
 $save_results=saveFile($contents, $filename);
 
 if($save_results[0]) { //this would be successful save        
 //this collects the success message 
 $error_messages.=$save_results[0]; 
 } else { //save so collect error messages in elements 1 - last
 $index=1;
 while($save_results[$index]) {
 $error_messages.=$save_results[$index];
 $index++;
 }
 }
 echo $error_messages;  
 NOTES:

 This is essentially the same as the appendToFile function, but the pointer is
 at the beginning, not the end of the file. It relies on these other
 functions:
 
 formatPath                                      
 isPathbad 

  ------------------------------------------------------------------------

A.67.7. SOURCE

 

    function saveFile($new_file_contents, $file_name)   {
    
       /* Save File over file_name (overwrites);

      returns an array of $save_results; $save_results[0] is true on success, false on failure
      and failure messages are in remaining elements of array */
    

          $new_file_contents=trim(stripslashes($new_file_contents));   //strip slashes from paths
          $filename_stripped=formatPath($file_name);
          $path_errors=isPathbad($file_name, true, false);
    

          if (!isset($path_errors)) { //check if directory is valid and file name is legal

              $fp = @fopen( $file_name,"w"); //open for writing, place file pointer at beginning of file, if does not exist attempt to create it
                 if (!$fp) {

                   $open_error="Error: File $filename_stripped Cannot Be opened. Check Permissions.<br>\n";
                 } else {
    
                 fwrite($fp,$new_file_contents);
                 fclose ($fp);

                 $save_results[0]="<strong>File $filename_stripped has been successfully saved.<strong><br>";
            
                 }
          $i=1;   
      
          } else {
    
              $i=2;

             $save_results[1]="Error: Cannot save file $filename_stripped.<br>";
            

              while ( list($file_or_dir, $error_message) = each($path_errors)) {
    
                while (list($each_message)  = each($error_message)) {
    

                  $save_results[$i].= $path_errors[$file_or_dir][$each_message];
                  $i++;
                }
            }
    
    
        }
        
        if ($open_error) {
    
            $save_results[$i]=$open_error;
        }
        
        return $save_results;
     
     }    

  ------------------------------------------------------------------------

A.68. phpcron_commonlib/deleteFile

  ------------------------------------------------------------------------

A.68.1. NAME

 

 deleteFile - deletes file in unix and dos

  ------------------------------------------------------------------------

A.68.2. SYNOPSIS

 

 boolean deleteFile(string $file_name)

  ------------------------------------------------------------------------

A.68.3. FUNCTION

 

 Deletes file $filename in dos or unix

  ------------------------------------------------------------------------

A.68.4. INPUTS

 

 $file_name - name of file to be deleted

  ------------------------------------------------------------------------

A.68.5. RESULT

 

 Returns true on success, false on failure

  ------------------------------------------------------------------------

A.68.6. NOTES

 

 Must define MS_WINDOWS constant like so in the calling script:
 
 if(preg_match("/WIN/", PHP_OS)) {
 define("MS_WINDOWS",true);
 } else {
 define("MS_WINDOWS",false);
 }

  ------------------------------------------------------------------------

A.68.7. SOURCE

 

     function deleteFile($file_name) {
    
    
     if (!file_exists($file_name)) {
      return true; //if file doesn't exist than don't worry about it
     }
     clearstatcache(); //clear cache since will be checking same file again
     $path_errors=isPathBad($file_name, true, true);
    
     if ( !$path_errors["directory"]["write"] and !$path_errors["file"])  {
    
       if(MS_WINDOWS) {
       $file_name=formatPath($file_name);
    
       exec("del $file_name");
    
       } else {
    
        unlink($file_name);
    
       }
       return true;
     } else {
    
    
     return false;    //return false if errors - can't write to path
     }
    }    

  ------------------------------------------------------------------------

A.69. phpcron_commonlib/isInteger

  ------------------------------------------------------------------------

A.69.1. NAME

 

 isInteger - tests whether a string contains integers only

  ------------------------------------------------------------------------

A.69.2. SYNOPSIS

 

 boolean isInteger(string $integer_string)

  ------------------------------------------------------------------------

A.69.3. FUNCTION

 

 Checks whether $integer_string contains only integers

  ------------------------------------------------------------------------

A.69.4. INPUTS

 

 $integer_string - string to be tested

  ------------------------------------------------------------------------

A.69.5. RESULT

 

 Returns true on success, false on failure

  ------------------------------------------------------------------------

A.69.6. SOURCE

 

    function isInteger ($integer_string) {
      /* It's false if the string is null */
      if (!isset($integer_string)) {
        return false;
      }
      $i=0;
      $length=strlen($integer_string);
      while($i<$length) {
      $ch=substr($integer_string,$i,1);
      if (ord($ch) < 48 or ord($ch) > 57) { //this tests 0 through 9
        return false;
      }
      $i++;
      }
      return true;
    
    }    

  ------------------------------------------------------------------------

A.70. phpcron_commonlib/isIntegerInRange

  ------------------------------------------------------------------------

A.70.1. NAME

 

 isIntegerInRange - tests whether an integer is within a named range

  ------------------------------------------------------------------------

A.70.2. SYNOPSIS

 

 boolean isIntegerInRange(string $integer_string, integer $low, integer
 $high)

  ------------------------------------------------------------------------

A.70.3. FUNCTION

 

 Checks whether $integer_string contains an integer equal to or between the
 values  of $low and $high.

  ------------------------------------------------------------------------

A.70.4. INPUTS

 

 $integer_string - string to be tested
 $low           - integer at low end of range
 $high  - integer at high end of range

  ------------------------------------------------------------------------

A.70.5. RESULT

 

 Returns true if tested string is outside of the $low and $high range, 
 false otherwise. Values that equal $low and $high will return true. 

  ------------------------------------------------------------------------

A.70.6. SOURCE

 

    function isIntegerInRange ($integer_string, $low, $high) {
    /* range is inclusive, so includes high and low values*/
    
        if  (!isInteger($integer_string)) {
    
        return false;
        }
    
        $myinteger=intval($integer_string);
        if (($myinteger < $low) or ($myinteger > $high)) {
        return false;
        } else {
        return true;
        }
    }    

  ------------------------------------------------------------------------

A.71. phpcron_commonlib/mailAttachment

  ------------------------------------------------------------------------

A.71.1. NAME

 

 mailAttachment - emails a file as a mime encoded attachment

  ------------------------------------------------------------------------

A.71.2. SYNOPSIS

 

 boolean mailAttachment( string $email_address, string $subject, 
 string $body, string $attachment, string $mimetype) 

  ------------------------------------------------------------------------

A.71.3. FUNCTION

 

 Mime encodes a file and emails it as an attachment. 

  ------------------------------------------------------------------------

A.71.4. INPUTS

 

 $email_address - the "To" email address
 $subject - Subject of email
 $body  - message to be included in the body of the email
 $attachment  - name of file to be attached
 $mimetype - mimetype of file to be encoded, e.g, "text/english"

  ------------------------------------------------------------------------

A.71.5. RESULT

 

 Returns an error message on failure. See the example below.

  ------------------------------------------------------------------------

A.71.6. EXAMPLE

 

 if($mailserver_error=mailAttachment
 ($admin_email_address, $subject, $body, $attachment, $mimetype)) {
 $error_messages.="Error: Unable to Email Log File:<br>\r\n".
 $mailserver_error;
 } else {          //it succeeded
 $error_messages.="Emailed Log File to $admin_email_address";
 }
 echo $error_messages;

  ------------------------------------------------------------------------

A.71.7. SOURCE

 

    function mailAttachment( $email_address, $subject, $body, $attachment, $mimetype)  {
    
    $boundary = md5(uniqid(time()));
    
    

    //MIME MUST be first character in headers - no spaces  or carriage returns
    $headers ="MIME-Version: 1.0
    Content-type: multipart/mixed;boundary=\"$boundary\"
    
    Multipart MIME message
    \r\n";
    
    $messagebody = "
    --$boundary
    Content-type: text/plain;charset=us-ascii
    Content-transfer-encoding: 8bit
    
    ".$body
    ."\r\n";
    
    $fp = fopen($attachment, "r");
    $attached_file = fread($fp, filesize($attachment));
    $attached_file = chunk_split(base64_encode($attached_file));
    $file_name = basename($attachment);
    
    $messagebody .= "
    --$boundary
    Content-type: ".$mimetype."; name=\"$file_name\"
    Content-transfer-encoding: base64
    Content-Disposition: attachment; filename=\"$file_name\"
    
    ".$attached_file
    ."
    
    ";
    
    
         // End of mail
         $messagebody .= "--$boundary--";
    

         $mail_result=@mail($email_address, $subject, $messagebody, $headers);
    
         if(!$mail_result) {
         $error_message="Mail message could not be sent.\r\n<br>
          Make sure you have a mail server installed and running.\r\n<br>";
          return $error_message; //returns true if unable to mail
         }
    }    

  ------------------------------------------------------------------------

A.72. phpcron_commonlib/isOtherPhpcrond

  ------------------------------------------------------------------------

A.72.1. NAME

 

 isOtherPhpcrond - checks to see if another phpcrond deamon process is running

  ------------------------------------------------------------------------

A.72.2. SYNOPSIS

 

 boolean  isOtherPhpcrond(void)

  ------------------------------------------------------------------------

A.72.3. FUNCTION

 

 Does a triple check (unix) or single check (dos) to see if another 
 phpcrond daemon is running. 
 
 In unix and dos it checks to see if the phpcron_psinfo_file exists in the 
 current directory of the script. 
 
 Under unix,the function will also 1) check the /tmp directory since  
 phpcrond will also generate a file there in unix if the directory exists  
 and is writeable, and 2) grep the ps command to see if it can detect an  
 instance of phpcron.

  ------------------------------------------------------------------------

A.72.4. PURPOSE

 

 It is vital that only one phpcrond daemon run at the same time - especially
 on a box  that is being used by many users (e.g., a virtual hosting box).
 This function  tries its best to detect whether such other instance is
 running. 

  ------------------------------------------------------------------------

A.72.5. RESULT

 

 Returns true if another instance of phpcrond is detected, false if not. 

  ------------------------------------------------------------------------

A.72.6. BUGS

 

 Since it relies on a specific use of the ps, the ps check may not work under 
 some versions of Unix. 

  ------------------------------------------------------------------------

A.72.7. SOURCE

 

    function isOtherPhpcrond() {
    

    /*Triple check done initially in phpcron.php to see if there is another instance running */
    
    global $phpcron_psinfo_file;
    $other_instance=false;
    $temp_path="$TEMP_DIR/".basename($phpcron_psinfo_file);
    
    if(file_exists($phpcron_psinfo_file)) {
        //Check to see if another instance is running
    
          deleteFile($phpcron_psinfo_file);

          sleep(1); //wait for phpcron to create again if there is another instance

          clearstatcache(); //clear cache since will be checking same file again
          if (file_exists($phpcron_psinfo_file)) {
          $other_instance=true;
    
    
          }
    
    }

    if(is_writeable("$TEMP_DIR/") and file_exists("$TEMP_DIR/".basename($phpcron_psinfo_file))) {
    
    
        //Check temp directory to see if a file ps info file is there
    
          deleteFile($temp_path);
    
          

          sleep(1); //wait for phpcron to create again if there is another instance

          clearstatcache(); //clear cache since will be checking same file again
          if (file_exists("$TEMP_DIR/".basename($phpcron_psinfo_file))) {
          $other_instance=true;
    
          }
    
    }
    
    
    //check in the tmp directory
    
    exec("ps ef | grep '^*phpcron.php*daemon.*$'",$output,$result_code);
    $number_of_instances=count($output);
    if($number_of_instances>1) {
    
    $other_instance=true;
    
    }
    
    return $other_instance;
    
    }    

  ------------------------------------------------------------------------

A.73. phpcron_commonlib/stopOtherPhpcron

  ------------------------------------------------------------------------

A.73.1. NAME

 

 stopOtherPhpcron

  ------------------------------------------------------------------------

A.73.2. SYNOPSIS

 

 boolean stopOtherPhpcron(void)

  ------------------------------------------------------------------------

A.73.3. FUNCTION

 

 Stops all Phpcron daemons that may be running. Does so by saving a  "stop"

 file ($phpcron_off) in the phpcron directory and in the $TEMP_DIR which when
 detected by phpcron.php will stop that process. 

  ------------------------------------------------------------------------

A.73.4. RESULT

 

 True on success, false on failure.

  ------------------------------------------------------------------------

A.73.5. SOURCE

 

    function stopOtherPhpcron(){
    
    /* Stops all phpcron daemons gracefully. */
    global $phpcron_off;
    
       
        $save_errors=saveFile("PHPCRON Stopped",$phpcron_off);
        
        $save_errors=implode("<br>",$save_errors);
       // echo "<br>".$save_errors;
     
        saveFile("PHPCRON Stopped","$TEMP_DIR/".basename($phpcron_off));
    
        sleep (1); //wait for it to stop
       

        return !isOtherPhpcrond(); //checks to see if any other phpcrond is still running and returns true/false
    
    }    

  ------------------------------------------------------------------------

A.74. phpcron_commonlib/parseCronTimeParams

  ------------------------------------------------------------------------

A.74.1. NAME

 

 parseCronTimeParams

  ------------------------------------------------------------------------

A.74.2. SYNOPSIS

 

 boolean parseCronTimeParams(string $time_param_string)

  ------------------------------------------------------------------------

A.74.3. FUNCTION

 

 Parses phpcrontab parameter string (minute, hour, date of month, day of week

 in traditional unix crontab format) and returns true or false whether current
 time matches. Implements ranges and alternate values and you can mix and
 match. E.g., you can do this: 18,20-25,20 1-2 * * *  

  ------------------------------------------------------------------------

A.74.4. RESULT

 

 True if matches current time, false on failure.

  ------------------------------------------------------------------------

A.74.5. SOURCE

 

    function parseCronTimeParams($time_param_string) {
    

    /* Parses phpcrontab parameter string (minute, hour, date of month, day of

    week in traditional unix crontab format) and returns true or false whether

    current time matches. Implements ranges and alternate values and you can mix
    and match. E.g., you can do this: 18,20-25,20 1-2 * * *       */
    
    
    /*Separate string by spaces, if it does not equal 5 then can't parse */
    
    if (count($tparams=explode(" ",$time_param_string)) <> 5) {
    return false;
    }
    
    /* Get Current time in same format as $time_param_string */
    $timestamp= trim(date("i H d m w"));
    
    /*Put individual vales of time stamp into sequential array */
    $timestamp=explode(" ",$timestamp);
    
    /*Main Loop - Cycle through each time parameter and match
    to actual time */
    
    $i=0;
    while (isset($tparams[$i])) {
    
    
    /***********Check for Asterisk************/
    
    if (preg_match("/^\*$/",$tparams[$i])) {
    
    $i++;
    continue 1; /*Go to Next Value*/
    } elseif (preg_match("/^".$timestamp[$i]."$/",$tparams[$i])) {
    
    /***********Check for Exact Match***********/
    
    $i++;
    continue 1; /*Go to Next Value*/

                                //a #    or    a range        comma optional [repeat one or more times to end]

    } elseif (preg_match("/^(([0-9]{1,2}|[0-9]{1,2}-[0-9]{1,2}),?)+$/",$tparams[$i])) {
    
    /**********Check for Comma and Ranges (can be mixed)*************/
    
    
    /*Separate Out Values Separated by Commas*/
    $alternate_values=explode(",",$tparams[$i]);
    $i_av=0;
    
    /*Cycle through each value to compare with corresponding time unit*/
    
    while (isset($alternate_values[$i_av])) {
    
    /* Check for individual number match */
    if ($alternate_values[$i_av]==$timestamp[$i]) {
    
     /*Continue with outer while loop since we have a match
    and try next value */
    $i++;
    
    continue 2;
    
    }
    
    /*Check if this alternate value is also a range*/
    

    if (preg_match("/^([0-9]{1,2}-[0-9]{1,2})$/",$alternate_values[$i_av])) {
    
    /*If so, check the range */
    
    /*Separate Out Low and High of Range Separated by Hyphen*/
    $range=explode("-",$alternate_values[$i_av]);
    
    if (isIntegerInRange($timestamp[$i], $range[0], $range[1])) {
    /* Continue with outer loop if it's within range */
    $i++;
    continue 2; 
    }
    
    } 
    
    
    $i_av++; /*Increment $alternate_values[$i_av] */
    }
    
    return false; //if it makes it this far there has been no matches
    
    } else {
    /* If doesn't match any of the patterns it's non-conforming */
    return false; 
    }
    
    $i++; /* Increment tparams[$i] value */
    }
    return true;
    
    }    

  ------------------------------------------------------------------------

A.75. phpcron_commonlib/isCronTimeParamsBad

  ------------------------------------------------------------------------

A.75.1. SYNOPSIS

 

 boolean isCronTimeParamsBad(string $time_param_string, int $command_number)

  ------------------------------------------------------------------------

A.75.2. FUNCTION

 

 Validates phpcrontab parameter string (minute, hour, date of month, day of

 week in traditional unix crontab format) and returns error messages (true) if
 string is bad or false if ok.  

  ------------------------------------------------------------------------

A.75.3. INPUTS

 

 string $time_param_string - a parameter string extracted from the 
                            phpcrontab.conf file (e.g., * 2-4,7,12 * * 3)

 int $command_number - line number in phpcrontrab.conf containing parameter 
                      string

  ------------------------------------------------------------------------

A.75.4. RESULT

 

 Error messages (true) if string is bad or false if ok.  

  ------------------------------------------------------------------------

A.75.5. SOURCE

 

    function isCronTimeParamsBad($time_param_string, $command_number) {
    
    
    /*Separate string by spaces, if it does not equal 5 then can't parse */
    
    if (count($tparams=explode(" ",trim($time_param_string))) <> 5) {

    $error_messages.="Error in Command #$command_number: Parameter String Must Have 5 Parameters.<br>";
    
    return $error_messages;
    }
    
    /* Set Correct high and low for each parameter */
    
     $correct_range[0]["low"] = 0;
     $correct_range[0]["high"] = 59;
     $correct_range[0]["unit"] = "Minutes";
     $correct_range[1]["low"] = 0;
     $correct_range[1]["high"] = 23;
     $correct_range[1]["unit"] = "Hour";
     $correct_range[2]["low"] = 1;
     $correct_range[2]["high"] = 31;
     $correct_range[2]["unit"] = "Day of Month";
     $correct_range[3]["low"] = 1;
     $correct_range[3]["high"] =12;
     $correct_range[3]["unit"] = "Month";
     $correct_range[4]["low"] = 0;
     $correct_range[4]["high"] = 6;
     $correct_range[4]["unit"] = "Day of Week";
      
     
    /*Main Loop - Cycle through each time parameter and validate*/
    
    $i=0;
    while (isset($tparams[$i])) {
    
    
    /***********Check for Asterisk************/
    
    if (preg_match("/^\*$/",$tparams[$i])) {
    
    $i++;
    continue 1; /*Go to Next Value*/
    } elseif (preg_match("/^[0-9]+$/",trim($tparams[$i]))) {
    
    /***********Check for Single Number***********/

    if (isIntegerInRange($tparams[$i], $correct_range[$i]["low"], $correct_range[$i]["high"])) {
    /* Continue with loop if it's within range */
    $i++;
    continue 1; 
    } else {
    

    $error_messages.="Error in Command #$command_number: ".$tparams[$i]." is an incorrect value for ".$correct_range[$i]["unit"].", it must be between ".$correct_range[$i]["low"]." and ".$correct_range[$i]["high"].".<br>\r\n";
    
    }
    

    } elseif (preg_match("/^(([0-9]{1,2}|[0-9]{1,2}-[0-9]{1,2}),?)+$/",$tparams[$i])) {
    
    /**********Check for Comma and Ranges (can be mixed)*************/
    
    
    /*Separate Out Values Separated by Commas*/
    
    $tparams[$i]=str_replace(",", " ", $tparams[$i]);
    
    //$error_messages.="Parameter String: $tparams[$i]<br>";
    $alternate_values=explode(" ",$tparams[$i]);
    
    $i_av=0;
    
    /*Cycle through each value to compare with corresponding time unit*/
    
    while (isset($alternate_values[$i_av])) {
    
    /*Check if it is a range */
            
    if(preg_match("/^[0-9]{1,2}-[0-9]{1,2}$/",$alternate_values[$i_av])) {
    
            $range=explode("-",$alternate_values[$i_av]);
            
            /*Make Sure High > Low */
            
            if ($range[0]>=$range[1]) {

            $error_messages.="Error in Command #$command_number: Low value of range ".$alternate_values[$i_av]." in ".$correct_range[$i]["unit"]." field is greater than or equal to high value.<br>\r\n";
            }
            $i_range=0;
            while(isset($range[$i_range])){

            if (!isIntegerInRange($range[$i_range], $correct_range[$i]["low"], $correct_range[$i]["high"])) {
    

            $error_messages.="Error in Command #$command_number: ".$range[$i_range]." is an incorrect value for ".$correct_range[$i]["unit"].", it must be between ".$correct_range[$i]["low"]." and ".$correct_range[$i]["high"].".<br>\r\n";
    
            }
            $i_range++;
            }
    
            $i_av++;
            continue; //continue with while loop
              
    }
    
    /*If not a range, check individual value*/
    
    //$error_messages.="Value: $alternate_values[$i_av]<br>";

    if (!isIntegerInRange($alternate_values[$i_av], $correct_range[$i]["low"], $correct_range[$i]["high"])) {
    
    

    $error_messages.="Error in Command #$command_number: ".$alternate_values[$i_av]." is an incorrect value for ".$correct_range[$i]["unit"].", it must be between ".$correct_range[$i]["low"]." and ".$correct_range[$i]["high"].".<br>\r\n";
    
    }
    
    
    $i_av++; /*Increment $alternate_values[$i_av] */
    }
    
    } else {
    /* If doesn't match any of the patterns it's non-conforming */

    $error_messages.="Error in Command #$command_number: The time parameters are in incorrect format<br>\r\n";
    
    }
    
    $i++; /* Increment tparams[$i] value */
    }
    return $error_messages;
    
    }    
    

  ------------------------------------------------------------------------

A.76. phpcron_commandlib/downloadFile

  ------------------------------------------------------------------------

A.76.1. NAME

 

 downloadFile

  ------------------------------------------------------------------------

A.76.2. SYNOPSIS

 

 boolean downloadFile(string $download_file_path, string $download_file_name)

  ------------------------------------------------------------------------

A.76.3. FUNCTION

 

 Sends an octet stream header to browser forcing a download of the file  found

 at $download_file_path with the $download_file_name.  It needs to be called
 before headers are sent and should end before any output is sent or use
 output buffering.  

  ------------------------------------------------------------------------

A.76.4. INPUTS

 

 string $download_file_path - path of the file to be downloaded
 string $download_file_name - file name which the download file will be
 saved as on the local computer (not the name
                             of the download file on the server)

  ------------------------------------------------------------------------

A.76.5. RESULT

 

 False on failure, true on success.

  ------------------------------------------------------------------------

A.76.6. EXAMPLE

 

 if($download_log) {
 $download_file_name="phpcron_logfile".date("mdy_H_i").".txt";    
 downloadFile($log_result_file, $download_file_name);
 exit;  
 }

  ------------------------------------------------------------------------

A.76.7. SOURCE

 

    function downloadFile($download_file_path, $download_file_name) {
       

    if (!$download_file_path or !file_exists($download_file_path) or !is_readable($download_file_path)) {
    
    return false;
    }
    $data=file($download_file_path);
    
    $data=trim(implode("",$data));
    
    header ("Content-length: " . strlen($data)); 
    header ("Content-type: application/octetstream");
    header ("Content-disposition: inline; filename=$download_file_name");
    
    print($data);
      
    return true;        
    }    
    

 References:
   1. http://phpcron.sourceforge.net/
   2. http://www.php.net
   3. http://www.gemini1consulting.com/tekhelp/
   4. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/html/
   5. http://www.gemini1consulting.com/tekhelp/
   6. http://www.docbook.org
   7. http://www.php.net
   8. www.gemini1consulting.com/dcd/ 
   9. mailto:ddruff@gemini1consulting.com
  10. mailto:ddruff@gemini1consulting.com
  11. mailto:ddruff@gemini1consulting.com
  12. http://www.gnu.org/licenses/license-list.html
  13. http://www.gemini1consulting.com/tekhelp/phpcron/docs/
  14. http://www.gemini1consulting.com
  15. http://www.sourceforge.net
  16. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/html/
  17. http://www.gemini1consulting.com/tekhelp/phpcron/docs/
  18. mailto:ddruff@gemini1consulting.com
  19. http://sourceforge.net/projects/phpcron/
  20. http://www.gemini1consulting.com/tekhelp/
  21. http://www.php.net
  22. http://www.php.net/manual/en/install.commandline.php
  23. http://www.php.net/manual/en/features.safe-mode.php
  24. http://www.php.net/manual/en/
  25. http://www.gemini1consulting.com/tekhelp/phpcron/demo/
  26.  http://sourceforge.net/projects/phpcron/
  27. http://www.gemini1consulting.com/tekhelp/
  28. http://www.docbook.org
  29. http://www.gemini1consulting.com/tekhelp/phpcron/docs/
  30. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  31. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  32. http://phpcron.sourceforge.net/
  33. http://www.sourceforge.net/projects/phpcron/
  34. http://www.xs4all.nl/~rfsber/Robo/robodoc.html
  35. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  36. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  37. http://phpcron.sourceforge.net/
  38. http://www.sourceforge.net/projects/phpcron/
  39. http://www.xs4all.nl/~rfsber/Robo/robodoc.html
  40. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  41. http://www.gemini1consulting.com/tekhelp/online_manuals/phpcron/
  42. http://phpcron.sourceforge.net/
  43. http://www.sourceforge.net/projects/phpcron/
  44. http://www.xs4all.nl/~rfsber/Robo/robodoc.html

